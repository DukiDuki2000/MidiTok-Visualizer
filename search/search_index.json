{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MidiTokVisualizer MIDI Processing and Visualization Library Welcome to the MidiTokVisualizer documentation! This library provides tools for processing, tokenizing, analyzing, and visualizing MIDI files through integration with the MidiTok package. Built on MidiTok MidiTokVisualizer builds upon the MidiTok Python package, a powerful open-source library for MIDI file tokenization introduced at the ISMIR 2021 conference. MidiTok enables the conversion of MIDI files into token sequences that can be fed to machine learning models like Transformers for various music generation, transcription, and analysis tasks. Supported Tokenizers MidiTokVisualizer currently supports the following tokenization methods from the MidiTok library: REMI : Represents music events based on relative timing and emphasizes musical structure MIDILike : A simpler representation that closely follows the raw MIDI message format TSD : Time-Shift-Duration tokenization which captures temporal relationships explicitly Structured : Provides a hierarchical representation of musical content CPWord : Compound Word tokenization for representing complex musical relationships Octuple : Multi-track tokenization with eight different token types MuMIDI : Multi-track tokenization that represents all tracks in a single token sequence MMM : Multi-track tokenization primarily designed for music inpainting and infilling PerTok : Per-token representation with advanced microtiming capabilities Each tokenizer comes with customizable parameters to adapt to different musical tasks and genres. Key Features Interactive Visualization : View MIDI files and their tokenized representations side by side Piano Roll Display : Visualize notes and their relationship to tokens Getting Started Running the Application MidiTokVisualizer can be run locally using Docker Compose or by setting up the development environment manually. Using Docker Compose (Recommended) The easiest way to run MidiTokVisualizer is with Docker Compose: # Clone the repository git clone https://github.com/justleon/MidiTok-Visualizer.git # Start the application docker compose up After running these commands, the application will be available at: Frontend: http://localhost:3000 Backend API: http://localhost:8000 Running the Application Manually Backend # Install Poetry if you don't have it pip install poetry # Setup and run the backend cd backend poetry install python main.py Frontend Requirements: Node.js 21+ and npm # Setup and run the frontend cd frontend npx serve -s build \" Running the Documentation To build and serve the documentation locally: # Serve the documentation mkdocs serve The documentation will be available at http://localhost:8000 . Online Deployment MidiTokVisualizer is also available online: Production deployment: https://miditok-visualizer-front-production.up.railway.app/ Documentation: https://dukiduki2000.github.io/MidiTok-Visualizer/","title":"MidiTokVisualizer"},{"location":"#miditokvisualizer","text":"","title":"MidiTokVisualizer"},{"location":"#midi-processing-and-visualization-library","text":"Welcome to the MidiTokVisualizer documentation! This library provides tools for processing, tokenizing, analyzing, and visualizing MIDI files through integration with the MidiTok package.","title":"MIDI Processing and Visualization Library"},{"location":"#built-on-miditok","text":"MidiTokVisualizer builds upon the MidiTok Python package, a powerful open-source library for MIDI file tokenization introduced at the ISMIR 2021 conference. MidiTok enables the conversion of MIDI files into token sequences that can be fed to machine learning models like Transformers for various music generation, transcription, and analysis tasks.","title":"Built on MidiTok"},{"location":"#supported-tokenizers","text":"MidiTokVisualizer currently supports the following tokenization methods from the MidiTok library: REMI : Represents music events based on relative timing and emphasizes musical structure MIDILike : A simpler representation that closely follows the raw MIDI message format TSD : Time-Shift-Duration tokenization which captures temporal relationships explicitly Structured : Provides a hierarchical representation of musical content CPWord : Compound Word tokenization for representing complex musical relationships Octuple : Multi-track tokenization with eight different token types MuMIDI : Multi-track tokenization that represents all tracks in a single token sequence MMM : Multi-track tokenization primarily designed for music inpainting and infilling PerTok : Per-token representation with advanced microtiming capabilities Each tokenizer comes with customizable parameters to adapt to different musical tasks and genres.","title":"Supported Tokenizers"},{"location":"#key-features","text":"Interactive Visualization : View MIDI files and their tokenized representations side by side Piano Roll Display : Visualize notes and their relationship to tokens","title":"Key Features"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#running-the-application","text":"MidiTokVisualizer can be run locally using Docker Compose or by setting up the development environment manually.","title":"Running the Application"},{"location":"#using-docker-compose-recommended","text":"The easiest way to run MidiTokVisualizer is with Docker Compose: # Clone the repository git clone https://github.com/justleon/MidiTok-Visualizer.git # Start the application docker compose up After running these commands, the application will be available at: Frontend: http://localhost:3000 Backend API: http://localhost:8000","title":"Using Docker Compose (Recommended)"},{"location":"#running-the-application-manually","text":"","title":"Running the Application Manually"},{"location":"#backend","text":"# Install Poetry if you don't have it pip install poetry # Setup and run the backend cd backend poetry install python main.py","title":"Backend"},{"location":"#frontend","text":"Requirements: Node.js 21+ and npm # Setup and run the frontend cd frontend npx serve -s build \"","title":"Frontend"},{"location":"#running-the-documentation","text":"To build and serve the documentation locally: # Serve the documentation mkdocs serve The documentation will be available at http://localhost:8000 .","title":"Running the Documentation"},{"location":"#online-deployment","text":"MidiTokVisualizer is also available online: Production deployment: https://miditok-visualizer-front-production.up.railway.app/ Documentation: https://dukiduki2000.github.io/MidiTok-Visualizer/","title":"Online Deployment"},{"location":"Development%20documentation/api/api/","text":"API This API provides endpoints for processing MIDI files. It uses FastAPI to create a RESTful API that can tokenize MIDI files, extract note information, and retrieve musical metrics. Overview The API has the following components: FastAPI Application : Handles HTTP requests and responses CORS Middleware : Configures Cross-Origin Resource Sharing Logging Middleware : Captures request/response details for debugging Exception Handlers : Manages validation and unexpected errors MidiProcessor : Core component for processing MIDI files Endpoints 1. Process MIDI File POST /process This endpoint processes a MIDI file according to the provided configuration. Request The request must be sent as multipart/form-data with the following fields: Field Type Description config string JSON configuration for MIDI processing file file MIDI file to process (.mid or .midi format) The config field should contain a JSON object that conforms to the ConfigModel schema. Response { \"success\" : true , \"data\" : { \"tokens\" : [ ... ], // Tokenized MIDI data \"notes\" : [ ... ], // Extracted notes with IDs \"metrics\" : { ... } // Musical metrics and information }, \"error\" : null } Error Responses 415 Unsupported Media Type : If the uploaded file is not a MIDI file 422 Unprocessable Entity : If the request parameters are invalid 500 Internal Server Error : If an unexpected error occurs during processing 2. Convert to MIDI POST /convert-to-midi/ This endpoint converts processed musical data back into a MIDI file format. Request Content-Type: application/json The request body should conform to the MIDIConversionRequest model structure: { \"output_filename\" : \"converted_song.mid\" , \"events\" : [ ... ], // Array of MIDI events \"tracks\" : [ ... ], // Track configuration // ... other conversion parameters } Response Success Response (200): - Content-Type : audio/midi - Content-Disposition : attachment; filename={output_filename} - Body : Binary MIDI file data The response is a streaming download of the generated MIDI file. Error Responses 500 Internal Server Error : If an error occurs during MIDI conversion { \"detail\" : \"An error occurred during MIDI conversion: {error_details}\" } Error Handling The API includes robust error handling: Validation Errors : Returns a 422 status code with a message indicating invalid parameters HTTP Exceptions : Returns the appropriate status code with a detailed error message Unexpected Errors : Returns a 500 status code and logs the full stack trace for debugging Implementation Details Process Endpoint Logic The /process endpoint performs these steps: Validates that the uploaded file is a MIDI file Parses the configuration from the form data Reads the MIDI file as bytes Tokenizes the MIDI file using the MidiProcessor Extracts note information and assigns unique note IDs Retrieves musical metrics and information Returns all processed data as a JSON response Environment Variables REACT_APP_API_BASE_URL : The base URL for the React application (default: \"http://localhost:3000\")","title":"API"},{"location":"Development%20documentation/api/api/#api","text":"This API provides endpoints for processing MIDI files. It uses FastAPI to create a RESTful API that can tokenize MIDI files, extract note information, and retrieve musical metrics.","title":"API"},{"location":"Development%20documentation/api/api/#overview","text":"The API has the following components: FastAPI Application : Handles HTTP requests and responses CORS Middleware : Configures Cross-Origin Resource Sharing Logging Middleware : Captures request/response details for debugging Exception Handlers : Manages validation and unexpected errors MidiProcessor : Core component for processing MIDI files","title":"Overview"},{"location":"Development%20documentation/api/api/#endpoints","text":"","title":"Endpoints"},{"location":"Development%20documentation/api/api/#1-process-midi-file","text":"POST /process This endpoint processes a MIDI file according to the provided configuration.","title":"1. Process MIDI File"},{"location":"Development%20documentation/api/api/#request","text":"The request must be sent as multipart/form-data with the following fields: Field Type Description config string JSON configuration for MIDI processing file file MIDI file to process (.mid or .midi format) The config field should contain a JSON object that conforms to the ConfigModel schema.","title":"Request"},{"location":"Development%20documentation/api/api/#response","text":"{ \"success\" : true , \"data\" : { \"tokens\" : [ ... ], // Tokenized MIDI data \"notes\" : [ ... ], // Extracted notes with IDs \"metrics\" : { ... } // Musical metrics and information }, \"error\" : null }","title":"Response"},{"location":"Development%20documentation/api/api/#error-responses","text":"415 Unsupported Media Type : If the uploaded file is not a MIDI file 422 Unprocessable Entity : If the request parameters are invalid 500 Internal Server Error : If an unexpected error occurs during processing","title":"Error Responses"},{"location":"Development%20documentation/api/api/#2-convert-to-midi","text":"POST /convert-to-midi/ This endpoint converts processed musical data back into a MIDI file format.","title":"2. Convert to MIDI"},{"location":"Development%20documentation/api/api/#request_1","text":"Content-Type: application/json The request body should conform to the MIDIConversionRequest model structure: { \"output_filename\" : \"converted_song.mid\" , \"events\" : [ ... ], // Array of MIDI events \"tracks\" : [ ... ], // Track configuration // ... other conversion parameters }","title":"Request"},{"location":"Development%20documentation/api/api/#response_1","text":"Success Response (200): - Content-Type : audio/midi - Content-Disposition : attachment; filename={output_filename} - Body : Binary MIDI file data The response is a streaming download of the generated MIDI file.","title":"Response"},{"location":"Development%20documentation/api/api/#error-responses_1","text":"500 Internal Server Error : If an error occurs during MIDI conversion { \"detail\" : \"An error occurred during MIDI conversion: {error_details}\" }","title":"Error Responses"},{"location":"Development%20documentation/api/api/#error-handling","text":"The API includes robust error handling: Validation Errors : Returns a 422 status code with a message indicating invalid parameters HTTP Exceptions : Returns the appropriate status code with a detailed error message Unexpected Errors : Returns a 500 status code and logs the full stack trace for debugging","title":"Error Handling"},{"location":"Development%20documentation/api/api/#implementation-details","text":"","title":"Implementation Details"},{"location":"Development%20documentation/api/api/#process-endpoint-logic","text":"The /process endpoint performs these steps: Validates that the uploaded file is a MIDI file Parses the configuration from the form data Reads the MIDI file as bytes Tokenizes the MIDI file using the MidiProcessor Extracts note information and assigns unique note IDs Retrieves musical metrics and information Returns all processed data as a JSON response","title":"Process Endpoint Logic"},{"location":"Development%20documentation/api/api/#environment-variables","text":"REACT_APP_API_BASE_URL : The base URL for the React application (default: \"http://localhost:3000\")","title":"Environment Variables"},{"location":"Development%20documentation/api/model/","text":"Model ConfigModel Configuration model that defines the parameters for MIDI tokenization and processing. class ConfigModel ( BaseModel ): Parameters Parameter Type Description tokenizer Literal The tokenization method to use. Options include \"REMI\", \"REMIPlus\", \"MIDILike\", \"TSD\", \"Structured\", \"CPWord\", \"Octuple\", \"MuMIDI\", \"MMM\", \"PerTok\". pitch_range list[int] A list containing the minimum and maximum MIDI pitch values to consider (0-127). num_velocities int The number of velocity levels to quantize to (0-127). special_tokens list[str] List of special tokens to include in the vocabulary. use_chords bool Whether to include chord tokens in the tokenization. use_rests bool Whether to include rest tokens in the tokenization. use_tempos bool Whether to include tempo tokens in the tokenization. use_time_signatures bool Whether to include time signature tokens in the tokenization. use_sustain_pedals bool Whether to include sustain pedal events in the tokenization. use_pitch_bends bool Whether to include pitch bend events in the tokenization. num_tempos NonNegativeInt The number of tempo levels to quantize to. tempo_range list[NonNegativeInt] A list containing the minimum and maximum tempo values in BPM. log_tempos bool Whether to use logarithmic scaling for tempo quantization. delete_equal_successive_tempo_changes bool Whether to remove consecutive identical tempo changes. sustain_pedal_duration bool Whether to include sustain pedal duration in tokenization. pitch_bend_range list[int] A list of three values defining the minimum, maximum, and step size for pitch bend. delete_equal_successive_time_sig_changes bool Whether to remove consecutive identical time signature changes. use_programs bool Whether to include program change events in the tokenization. programs Optional[list[int]] Optional range of MIDI program numbers to include. one_token_stream_for_programs Optional[bool] Whether to use a single token stream for all programs. program_changes Optional[bool] Whether to include program change events. use_microtiming bool Whether to include microtiming information. ticks_per_quarter int MIDI ticks per quarter note (24-960). max_microtiming_shift float Maximum microtiming shift as a fraction of a beat (0-1). num_microtiming_bins int Number of bins for quantizing microtiming (1-64). MusicInformationData Model that contains extracted information and metrics from a MIDI file. class MusicInformationData ( BaseModel ): Parameters Parameter Type Description title str The title of the MIDI file. resolution PositiveInt The MIDI file resolution (ticks per quarter note). tempos list[tuple[NonNegativeInt, float]] List of tempo changes as (tick, tempo in BPM) pairs. key_signatures list[tuple[NonNegativeInt, int, str]] List of key signature changes as (tick, key, mode) triplets. time_signatures list[tuple[NonNegativeInt, int, int]] List of time signature changes as (tick, numerator, denominator) triplets. pitch_range NonNegativeInt The range between the highest and lowest pitch used in the MIDI file. n_pitches_used NonNegativeInt The number of unique pitches used in the MIDI file. polyphony NonNegativeFloat The average number of simultaneous notes played. empty_beat_rate NonNegativeFloat The ratio of beats with no notes to total beats. drum_pattern_consistency NonNegativeFloat A measure of how consistent drum patterns are throughout the MIDI file (0-1). BasicInfoData Data class that contains basic information extracted from a MIDI file. @dataclass class BasicInfoData : Parameters Parameter Type Description title str The title of the MIDI file. resolution int The MIDI file resolution (ticks per quarter note). tempos list[tuple[int, float]] List of tempo changes as (tick, tempo in BPM) pairs. key_signatures list[tuple[int, int, str]] List of key signature changes as (tick, key, mode) triplets. time_signatures list[tuple[int, int, int]] List of time signature changes as (tick, numerator, denominator) triplets. MetricsData Data class that contains calculated metrics from a MIDI file. @dataclass class MetricsData : Parameters Parameter Type Description pitch_range int The range between the highest and lowest pitch used in the MIDI file. n_pitches_used int The number of unique pitches used in the MIDI file. polyphony float The average number of simultaneous notes played. empty_beat_rate float The ratio of beats with no notes to total beats. drum_pattern_consistency float A measure of how consistent drum patterns are throughout the MIDI file (0-1). Note Data class representing a single note in a MIDI file. @dataclass class Note : Parameters Parameter Type Description pitch int The MIDI pitch value of the note (0-127). name str The note name (e.g., \"C4\", \"F#5\"). start int The start time of the note in MIDI ticks. end int The end time of the note in MIDI ticks. velocity int The velocity (loudness) of the note (0-127).","title":"Model"},{"location":"Development%20documentation/api/model/#model","text":"","title":"Model"},{"location":"Development%20documentation/api/model/#configmodel","text":"Configuration model that defines the parameters for MIDI tokenization and processing. class ConfigModel ( BaseModel ):","title":"ConfigModel"},{"location":"Development%20documentation/api/model/#parameters","text":"Parameter Type Description tokenizer Literal The tokenization method to use. Options include \"REMI\", \"REMIPlus\", \"MIDILike\", \"TSD\", \"Structured\", \"CPWord\", \"Octuple\", \"MuMIDI\", \"MMM\", \"PerTok\". pitch_range list[int] A list containing the minimum and maximum MIDI pitch values to consider (0-127). num_velocities int The number of velocity levels to quantize to (0-127). special_tokens list[str] List of special tokens to include in the vocabulary. use_chords bool Whether to include chord tokens in the tokenization. use_rests bool Whether to include rest tokens in the tokenization. use_tempos bool Whether to include tempo tokens in the tokenization. use_time_signatures bool Whether to include time signature tokens in the tokenization. use_sustain_pedals bool Whether to include sustain pedal events in the tokenization. use_pitch_bends bool Whether to include pitch bend events in the tokenization. num_tempos NonNegativeInt The number of tempo levels to quantize to. tempo_range list[NonNegativeInt] A list containing the minimum and maximum tempo values in BPM. log_tempos bool Whether to use logarithmic scaling for tempo quantization. delete_equal_successive_tempo_changes bool Whether to remove consecutive identical tempo changes. sustain_pedal_duration bool Whether to include sustain pedal duration in tokenization. pitch_bend_range list[int] A list of three values defining the minimum, maximum, and step size for pitch bend. delete_equal_successive_time_sig_changes bool Whether to remove consecutive identical time signature changes. use_programs bool Whether to include program change events in the tokenization. programs Optional[list[int]] Optional range of MIDI program numbers to include. one_token_stream_for_programs Optional[bool] Whether to use a single token stream for all programs. program_changes Optional[bool] Whether to include program change events. use_microtiming bool Whether to include microtiming information. ticks_per_quarter int MIDI ticks per quarter note (24-960). max_microtiming_shift float Maximum microtiming shift as a fraction of a beat (0-1). num_microtiming_bins int Number of bins for quantizing microtiming (1-64).","title":"Parameters"},{"location":"Development%20documentation/api/model/#musicinformationdata","text":"Model that contains extracted information and metrics from a MIDI file. class MusicInformationData ( BaseModel ):","title":"MusicInformationData"},{"location":"Development%20documentation/api/model/#parameters_1","text":"Parameter Type Description title str The title of the MIDI file. resolution PositiveInt The MIDI file resolution (ticks per quarter note). tempos list[tuple[NonNegativeInt, float]] List of tempo changes as (tick, tempo in BPM) pairs. key_signatures list[tuple[NonNegativeInt, int, str]] List of key signature changes as (tick, key, mode) triplets. time_signatures list[tuple[NonNegativeInt, int, int]] List of time signature changes as (tick, numerator, denominator) triplets. pitch_range NonNegativeInt The range between the highest and lowest pitch used in the MIDI file. n_pitches_used NonNegativeInt The number of unique pitches used in the MIDI file. polyphony NonNegativeFloat The average number of simultaneous notes played. empty_beat_rate NonNegativeFloat The ratio of beats with no notes to total beats. drum_pattern_consistency NonNegativeFloat A measure of how consistent drum patterns are throughout the MIDI file (0-1).","title":"Parameters"},{"location":"Development%20documentation/api/model/#basicinfodata","text":"Data class that contains basic information extracted from a MIDI file. @dataclass class BasicInfoData :","title":"BasicInfoData"},{"location":"Development%20documentation/api/model/#parameters_2","text":"Parameter Type Description title str The title of the MIDI file. resolution int The MIDI file resolution (ticks per quarter note). tempos list[tuple[int, float]] List of tempo changes as (tick, tempo in BPM) pairs. key_signatures list[tuple[int, int, str]] List of key signature changes as (tick, key, mode) triplets. time_signatures list[tuple[int, int, int]] List of time signature changes as (tick, numerator, denominator) triplets.","title":"Parameters"},{"location":"Development%20documentation/api/model/#metricsdata","text":"Data class that contains calculated metrics from a MIDI file. @dataclass class MetricsData :","title":"MetricsData"},{"location":"Development%20documentation/api/model/#parameters_3","text":"Parameter Type Description pitch_range int The range between the highest and lowest pitch used in the MIDI file. n_pitches_used int The number of unique pitches used in the MIDI file. polyphony float The average number of simultaneous notes played. empty_beat_rate float The ratio of beats with no notes to total beats. drum_pattern_consistency float A measure of how consistent drum patterns are throughout the MIDI file (0-1).","title":"Parameters"},{"location":"Development%20documentation/api/model/#note","text":"Data class representing a single note in a MIDI file. @dataclass class Note :","title":"Note"},{"location":"Development%20documentation/api/model/#parameters_4","text":"Parameter Type Description pitch int The MIDI pitch value of the note (0-127). name str The note name (e.g., \"C4\", \"F#5\"). start int The start time of the note in MIDI ticks. end int The end time of the note in MIDI ticks. velocity int The velocity (loudness) of the note (0-127).","title":"Parameters"},{"location":"Development%20documentation/service/MidiEvent/","text":"MIDI Event Classes MidiEvent Source code in backend/core/service/midi/midi_event.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class MidiEvent : def __init__ ( self , ticks_per_beat = 480 ): self . ticks_per_beat = ticks_per_beat def create_midi_file_from_events ( self , params : MIDIConversionRequest ) -> MidiFile : \"\"\" Creates a MIDI file from a collection of high-level MIDI events grouped by track. Args: params (MIDIConversionRequest): MIDI conversion input data. Returns: MidiFile: A fully structured MIDI file object. \"\"\" ticks_per_beat = getattr ( params , 'ticks_per_beat' , self . ticks_per_beat ) mid = MidiFile ( ticks_per_beat = ticks_per_beat ) events_by_track = self . _group_events_by_track ( params . events ) for track_num in sorted ( events_by_track . keys ()): primitive_events = self . _convert_and_sort_primitive_events ( events_by_track [ track_num ]) midi_track = self . _create_midi_track ( primitive_events ) mid . tracks . append ( midi_track ) return mid def _group_events_by_track ( self , events ) -> Dict [ int , List [ dict ]]: \"\"\" Groups high-level MIDI events by their track number. Args: events: List of event wrapper objects. Returns: Dict[int, List[object]]: Events grouped by track number. \"\"\" grouped : Dict [ int , List [ object ]] = {} for event_wrapper in events : event = event_wrapper . root track = event . track if track not in grouped : grouped [ track ] = [] grouped [ track ] . append ( event ) return grouped def _convert_and_sort_primitive_events ( self , events : List [ object ]) -> List [ dict ]: \"\"\" Converts high-level MIDI events to primitive events and sorts them. Args: events: List of high-level MIDI events. Returns: List[dict]: Sorted primitive MIDI events. \"\"\" primitives : List [ dict ] = [] for event in events : if event . event_type == \"note\" : primitives . append ({ 'time' : event . time , 'type' : 'note_on' , 'pitch' : event . pitch , 'velocity' : event . velocity , 'channel' : event . channel }) primitives . append ({ 'time' : event . time + event . duration , 'type' : 'note_off' , 'pitch' : event . pitch , 'velocity' : event . velocity , 'channel' : event . channel }) elif event . event_type == \"tempo\" : primitives . append ({ 'time' : event . time , 'type' : 'set_tempo' , 'bpm' : event . bpm }) return sorted ( primitives , key = lambda x : ( x [ 'time' ], 0 if x [ 'type' ] == 'set_tempo' else ( 1 if x [ 'type' ] == 'note_off' else 2 ) )) def _create_midi_track ( self , primitive_events : List [ dict ]) -> MidiTrack : \"\"\" Creates a MidiTrack and adds primitive events to it with proper delta times. Args: primitive_events: List of sorted primitive MIDI events. Returns: MidiTrack: A populated MIDI track. \"\"\" track = MidiTrack () current_time = 0 for event in primitive_events : delta = event [ 'time' ] - current_time if delta < 0 : print ( f \"Warning: Negative delta time ( { delta } ) \u2013 clamped to 0. Event: { event } \" ) delta = 0 if event [ 'type' ] == 'note_on' : track . append ( Message ( 'note_on' , note = event [ 'pitch' ], velocity = event [ 'velocity' ], time = delta , channel = event [ 'channel' ])) elif event [ 'type' ] == 'note_off' : track . append ( Message ( 'note_off' , note = event [ 'pitch' ], velocity = event [ 'velocity' ], time = delta , channel = event [ 'channel' ])) elif event [ 'type' ] == 'set_tempo' : tempo = bpm2tempo ( event [ 'bpm' ]) track . append ( MetaMessage ( 'set_tempo' , tempo = tempo , time = delta )) current_time = event [ 'time' ] if not any ( msg . is_meta and msg . type == 'end_of_track' for msg in track ): track . append ( MetaMessage ( 'end_of_track' , time = 0 )) return track Functions create_midi_file_from_events ( params : MIDIConversionRequest ) -> MidiFile Creates a MIDI file from a collection of high-level MIDI events grouped by track. Parameters: params ( MIDIConversionRequest ) \u2013 MIDI conversion input data. Returns: MidiFile ( MidiFile ) \u2013 A fully structured MIDI file object. Source code in backend/core/service/midi/midi_event.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def create_midi_file_from_events ( self , params : MIDIConversionRequest ) -> MidiFile : \"\"\" Creates a MIDI file from a collection of high-level MIDI events grouped by track. Args: params (MIDIConversionRequest): MIDI conversion input data. Returns: MidiFile: A fully structured MIDI file object. \"\"\" ticks_per_beat = getattr ( params , 'ticks_per_beat' , self . ticks_per_beat ) mid = MidiFile ( ticks_per_beat = ticks_per_beat ) events_by_track = self . _group_events_by_track ( params . events ) for track_num in sorted ( events_by_track . keys ()): primitive_events = self . _convert_and_sort_primitive_events ( events_by_track [ track_num ]) midi_track = self . _create_midi_track ( primitive_events ) mid . tracks . append ( midi_track ) return mid","title":"MIDI Event"},{"location":"Development%20documentation/service/MidiEvent/#midi-event","text":"","title":"MIDI Event"},{"location":"Development%20documentation/service/MidiEvent/#backend.core.service.midi.midi_event-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/MidiEvent/#backend.core.service.midi.midi_event.MidiEvent","text":"Source code in backend/core/service/midi/midi_event.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class MidiEvent : def __init__ ( self , ticks_per_beat = 480 ): self . ticks_per_beat = ticks_per_beat def create_midi_file_from_events ( self , params : MIDIConversionRequest ) -> MidiFile : \"\"\" Creates a MIDI file from a collection of high-level MIDI events grouped by track. Args: params (MIDIConversionRequest): MIDI conversion input data. Returns: MidiFile: A fully structured MIDI file object. \"\"\" ticks_per_beat = getattr ( params , 'ticks_per_beat' , self . ticks_per_beat ) mid = MidiFile ( ticks_per_beat = ticks_per_beat ) events_by_track = self . _group_events_by_track ( params . events ) for track_num in sorted ( events_by_track . keys ()): primitive_events = self . _convert_and_sort_primitive_events ( events_by_track [ track_num ]) midi_track = self . _create_midi_track ( primitive_events ) mid . tracks . append ( midi_track ) return mid def _group_events_by_track ( self , events ) -> Dict [ int , List [ dict ]]: \"\"\" Groups high-level MIDI events by their track number. Args: events: List of event wrapper objects. Returns: Dict[int, List[object]]: Events grouped by track number. \"\"\" grouped : Dict [ int , List [ object ]] = {} for event_wrapper in events : event = event_wrapper . root track = event . track if track not in grouped : grouped [ track ] = [] grouped [ track ] . append ( event ) return grouped def _convert_and_sort_primitive_events ( self , events : List [ object ]) -> List [ dict ]: \"\"\" Converts high-level MIDI events to primitive events and sorts them. Args: events: List of high-level MIDI events. Returns: List[dict]: Sorted primitive MIDI events. \"\"\" primitives : List [ dict ] = [] for event in events : if event . event_type == \"note\" : primitives . append ({ 'time' : event . time , 'type' : 'note_on' , 'pitch' : event . pitch , 'velocity' : event . velocity , 'channel' : event . channel }) primitives . append ({ 'time' : event . time + event . duration , 'type' : 'note_off' , 'pitch' : event . pitch , 'velocity' : event . velocity , 'channel' : event . channel }) elif event . event_type == \"tempo\" : primitives . append ({ 'time' : event . time , 'type' : 'set_tempo' , 'bpm' : event . bpm }) return sorted ( primitives , key = lambda x : ( x [ 'time' ], 0 if x [ 'type' ] == 'set_tempo' else ( 1 if x [ 'type' ] == 'note_off' else 2 ) )) def _create_midi_track ( self , primitive_events : List [ dict ]) -> MidiTrack : \"\"\" Creates a MidiTrack and adds primitive events to it with proper delta times. Args: primitive_events: List of sorted primitive MIDI events. Returns: MidiTrack: A populated MIDI track. \"\"\" track = MidiTrack () current_time = 0 for event in primitive_events : delta = event [ 'time' ] - current_time if delta < 0 : print ( f \"Warning: Negative delta time ( { delta } ) \u2013 clamped to 0. Event: { event } \" ) delta = 0 if event [ 'type' ] == 'note_on' : track . append ( Message ( 'note_on' , note = event [ 'pitch' ], velocity = event [ 'velocity' ], time = delta , channel = event [ 'channel' ])) elif event [ 'type' ] == 'note_off' : track . append ( Message ( 'note_off' , note = event [ 'pitch' ], velocity = event [ 'velocity' ], time = delta , channel = event [ 'channel' ])) elif event [ 'type' ] == 'set_tempo' : tempo = bpm2tempo ( event [ 'bpm' ]) track . append ( MetaMessage ( 'set_tempo' , tempo = tempo , time = delta )) current_time = event [ 'time' ] if not any ( msg . is_meta and msg . type == 'end_of_track' for msg in track ): track . append ( MetaMessage ( 'end_of_track' , time = 0 )) return track","title":"MidiEvent"},{"location":"Development%20documentation/service/MidiEvent/#backend.core.service.midi.midi_event.MidiEvent-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/MidiEvent/#backend.core.service.midi.midi_event.MidiEvent.create_midi_file_from_events","text":"Creates a MIDI file from a collection of high-level MIDI events grouped by track. Parameters: params ( MIDIConversionRequest ) \u2013 MIDI conversion input data. Returns: MidiFile ( MidiFile ) \u2013 A fully structured MIDI file object. Source code in backend/core/service/midi/midi_event.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def create_midi_file_from_events ( self , params : MIDIConversionRequest ) -> MidiFile : \"\"\" Creates a MIDI file from a collection of high-level MIDI events grouped by track. Args: params (MIDIConversionRequest): MIDI conversion input data. Returns: MidiFile: A fully structured MIDI file object. \"\"\" ticks_per_beat = getattr ( params , 'ticks_per_beat' , self . ticks_per_beat ) mid = MidiFile ( ticks_per_beat = ticks_per_beat ) events_by_track = self . _group_events_by_track ( params . events ) for track_num in sorted ( events_by_track . keys ()): primitive_events = self . _convert_and_sort_primitive_events ( events_by_track [ track_num ]) midi_track = self . _create_midi_track ( primitive_events ) mid . tracks . append ( midi_track ) return mid","title":"create_midi_file_from_events"},{"location":"Development%20documentation/service/MidiInfoExtractor/","text":"MIDI Info Extractor Classes MidiInformationExtractor Class for extracting musical information and metrics from MIDI files. Source code in backend/core/service/midi/midi_info_extractor.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class MidiInformationExtractor : \"\"\" Class for extracting musical information and metrics from MIDI files. \"\"\" def __init__ ( self ): pass def extract_information ( self , midi_file_music : muspy . Music ) -> MusicInformationData : \"\"\" Extracts and returns information from a MIDI file. Args: midi_file_music: MIDI file loaded as muspy.Music object Returns: MusicInformationData with information about the MIDI file Raises: ValueError: If the music information data couldn't be created \"\"\" basic_data = self . _extract_basic_data ( midi_file_music ) metrics = self . _extract_metrics ( midi_file_music ) music_info_data = self . _create_music_info_data ( basic_data , metrics ) if music_info_data is None : raise ValueError ( \"Couldn't handle music information data\" ) return music_info_data def _create_music_info_data ( self , basic_info : BasicInfoData , metrics_data : MetricsData ) -> Optional [ MusicInformationData ]: \"\"\" Creates MusicInformationData object from basic info and metrics. Args: basic_info: Basic information about the MIDI file metrics_data: Metrics extracted from the MIDI file Returns: MusicInformationData object or None if validation fails \"\"\" try : data = MusicInformationData ( title = basic_info . title , resolution = basic_info . resolution , tempos = basic_info . tempos , key_signatures = basic_info . key_signatures , time_signatures = basic_info . time_signatures , pitch_range = metrics_data . pitch_range , n_pitches_used = metrics_data . n_pitches_used , polyphony = metrics_data . polyphony , empty_beat_rate = metrics_data . empty_beat_rate , drum_pattern_consistency = metrics_data . drum_pattern_consistency , ) return data except pydantic . ValidationError as e : print ( e ) return None def _extract_basic_data ( self , music_file : muspy . Music ) -> BasicInfoData : \"\"\" Extracts basic data from a MIDI file. Args: music_file: MIDI file loaded as muspy.Music object Returns: BasicInfoData with basic information about the MIDI file \"\"\" tempos : List [ Tuple [ int , float ]] = [] for tempo in music_file . tempos : tempo_data : Tuple [ int , float ] = ( tempo . time , tempo . qpm ) tempos . append ( tempo_data ) key_signatures : List [ Tuple [ int , int , str ]] = [] for key_signature in music_file . key_signatures : signature_data : Tuple [ int , int , str ] = ( key_signature . time , key_signature . root , key_signature . mode ) key_signatures . append ( signature_data ) time_signatures : List [ Tuple [ int , int , int ]] = [] for time_signature in music_file . time_signatures : time_data : Tuple [ int , int , int ] = ( time_signature . time , time_signature . numerator , time_signature . denominator ) time_signatures . append ( time_data ) return BasicInfoData ( music_file . metadata . title , music_file . resolution , tempos , key_signatures , time_signatures ) def _extract_metrics ( self , music_file : muspy . Music ) -> MetricsData : \"\"\" Extracts metrics from a MIDI file. Args: music_file: MIDI file loaded as muspy.Music object Returns: MetricsData with metrics extracted from the MIDI file \"\"\" pitch_range = muspy . pitch_range ( music_file ) n_pitches_used = muspy . n_pitches_used ( music_file ) polyphony_rate = muspy . polyphony ( music_file ) if math . isnan ( polyphony_rate ): polyphony_rate = 0.0 empty_beat_rate = muspy . empty_beat_rate ( music_file ) if math . isnan ( empty_beat_rate ): empty_beat_rate = 0.0 drum_pattern_consistency = muspy . drum_pattern_consistency ( music_file ) if math . isnan ( drum_pattern_consistency ): drum_pattern_consistency = 0.0 return MetricsData ( pitch_range , n_pitches_used , polyphony_rate , empty_beat_rate , drum_pattern_consistency ) Functions extract_information ( midi_file_music : muspy . Music ) -> MusicInformationData Extracts and returns information from a MIDI file. Parameters: midi_file_music ( Music ) \u2013 MIDI file loaded as muspy.Music object Returns: MusicInformationData \u2013 MusicInformationData with information about the MIDI file Raises: ValueError \u2013 If the music information data couldn't be created Source code in backend/core/service/midi/midi_info_extractor.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def extract_information ( self , midi_file_music : muspy . Music ) -> MusicInformationData : \"\"\" Extracts and returns information from a MIDI file. Args: midi_file_music: MIDI file loaded as muspy.Music object Returns: MusicInformationData with information about the MIDI file Raises: ValueError: If the music information data couldn't be created \"\"\" basic_data = self . _extract_basic_data ( midi_file_music ) metrics = self . _extract_metrics ( midi_file_music ) music_info_data = self . _create_music_info_data ( basic_data , metrics ) if music_info_data is None : raise ValueError ( \"Couldn't handle music information data\" ) return music_info_data","title":"MIDI Info Extractor"},{"location":"Development%20documentation/service/MidiInfoExtractor/#midi-info-extractor","text":"","title":"MIDI Info Extractor"},{"location":"Development%20documentation/service/MidiInfoExtractor/#backend.core.service.midi.midi_info_extractor-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/MidiInfoExtractor/#backend.core.service.midi.midi_info_extractor.MidiInformationExtractor","text":"Class for extracting musical information and metrics from MIDI files. Source code in backend/core/service/midi/midi_info_extractor.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class MidiInformationExtractor : \"\"\" Class for extracting musical information and metrics from MIDI files. \"\"\" def __init__ ( self ): pass def extract_information ( self , midi_file_music : muspy . Music ) -> MusicInformationData : \"\"\" Extracts and returns information from a MIDI file. Args: midi_file_music: MIDI file loaded as muspy.Music object Returns: MusicInformationData with information about the MIDI file Raises: ValueError: If the music information data couldn't be created \"\"\" basic_data = self . _extract_basic_data ( midi_file_music ) metrics = self . _extract_metrics ( midi_file_music ) music_info_data = self . _create_music_info_data ( basic_data , metrics ) if music_info_data is None : raise ValueError ( \"Couldn't handle music information data\" ) return music_info_data def _create_music_info_data ( self , basic_info : BasicInfoData , metrics_data : MetricsData ) -> Optional [ MusicInformationData ]: \"\"\" Creates MusicInformationData object from basic info and metrics. Args: basic_info: Basic information about the MIDI file metrics_data: Metrics extracted from the MIDI file Returns: MusicInformationData object or None if validation fails \"\"\" try : data = MusicInformationData ( title = basic_info . title , resolution = basic_info . resolution , tempos = basic_info . tempos , key_signatures = basic_info . key_signatures , time_signatures = basic_info . time_signatures , pitch_range = metrics_data . pitch_range , n_pitches_used = metrics_data . n_pitches_used , polyphony = metrics_data . polyphony , empty_beat_rate = metrics_data . empty_beat_rate , drum_pattern_consistency = metrics_data . drum_pattern_consistency , ) return data except pydantic . ValidationError as e : print ( e ) return None def _extract_basic_data ( self , music_file : muspy . Music ) -> BasicInfoData : \"\"\" Extracts basic data from a MIDI file. Args: music_file: MIDI file loaded as muspy.Music object Returns: BasicInfoData with basic information about the MIDI file \"\"\" tempos : List [ Tuple [ int , float ]] = [] for tempo in music_file . tempos : tempo_data : Tuple [ int , float ] = ( tempo . time , tempo . qpm ) tempos . append ( tempo_data ) key_signatures : List [ Tuple [ int , int , str ]] = [] for key_signature in music_file . key_signatures : signature_data : Tuple [ int , int , str ] = ( key_signature . time , key_signature . root , key_signature . mode ) key_signatures . append ( signature_data ) time_signatures : List [ Tuple [ int , int , int ]] = [] for time_signature in music_file . time_signatures : time_data : Tuple [ int , int , int ] = ( time_signature . time , time_signature . numerator , time_signature . denominator ) time_signatures . append ( time_data ) return BasicInfoData ( music_file . metadata . title , music_file . resolution , tempos , key_signatures , time_signatures ) def _extract_metrics ( self , music_file : muspy . Music ) -> MetricsData : \"\"\" Extracts metrics from a MIDI file. Args: music_file: MIDI file loaded as muspy.Music object Returns: MetricsData with metrics extracted from the MIDI file \"\"\" pitch_range = muspy . pitch_range ( music_file ) n_pitches_used = muspy . n_pitches_used ( music_file ) polyphony_rate = muspy . polyphony ( music_file ) if math . isnan ( polyphony_rate ): polyphony_rate = 0.0 empty_beat_rate = muspy . empty_beat_rate ( music_file ) if math . isnan ( empty_beat_rate ): empty_beat_rate = 0.0 drum_pattern_consistency = muspy . drum_pattern_consistency ( music_file ) if math . isnan ( drum_pattern_consistency ): drum_pattern_consistency = 0.0 return MetricsData ( pitch_range , n_pitches_used , polyphony_rate , empty_beat_rate , drum_pattern_consistency )","title":"MidiInformationExtractor"},{"location":"Development%20documentation/service/MidiInfoExtractor/#backend.core.service.midi.midi_info_extractor.MidiInformationExtractor-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/MidiInfoExtractor/#backend.core.service.midi.midi_info_extractor.MidiInformationExtractor.extract_information","text":"Extracts and returns information from a MIDI file. Parameters: midi_file_music ( Music ) \u2013 MIDI file loaded as muspy.Music object Returns: MusicInformationData \u2013 MusicInformationData with information about the MIDI file Raises: ValueError \u2013 If the music information data couldn't be created Source code in backend/core/service/midi/midi_info_extractor.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def extract_information ( self , midi_file_music : muspy . Music ) -> MusicInformationData : \"\"\" Extracts and returns information from a MIDI file. Args: midi_file_music: MIDI file loaded as muspy.Music object Returns: MusicInformationData with information about the MIDI file Raises: ValueError: If the music information data couldn't be created \"\"\" basic_data = self . _extract_basic_data ( midi_file_music ) metrics = self . _extract_metrics ( midi_file_music ) music_info_data = self . _create_music_info_data ( basic_data , metrics ) if music_info_data is None : raise ValueError ( \"Couldn't handle music information data\" ) return music_info_data","title":"extract_information"},{"location":"Development%20documentation/service/MidiLoader/","text":"MIDI Loader Class Classes MidiLoader Utility class for loading MIDI files using different MIDI processing libraries. This class provides methods to load MIDI data using both miditoolkit and mido libraries, which offer different capabilities for MIDI file manipulation and analysis. The class handles the conversion of raw bytes to MIDI objects that can be processed by these libraries. Source code in backend/core/service/midi/midi_loader.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MidiLoader : \"\"\" Utility class for loading MIDI files using different MIDI processing libraries. This class provides methods to load MIDI data using both miditoolkit and mido libraries, which offer different capabilities for MIDI file manipulation and analysis. The class handles the conversion of raw bytes to MIDI objects that can be processed by these libraries. \"\"\" def __init__ ( self ): pass def load_midi_toolkit ( self , midi_bytes : bytes ) -> MidiToolkitFile : \"\"\" Load a MIDI file using the miditoolkit library. This method converts raw bytes into a MidiToolkitFile object, which provides comprehensive capabilities for MIDI manipulation, including note extraction, tempo and time signature analysis, and more. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidiToolkitFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using miditoolkit, with details about the specific error. \"\"\" try : return MidiToolkitFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with MidiToolkit: { str ( e ) } \" ) def load_mido_midi ( self , midi_bytes : bytes ) -> MidoMidiFile : \"\"\" Load a MIDI file using the mido library. This method converts raw bytes into a MidoMidiFile object, which provides low-level access to MIDI messages and is useful for MIDI message manipulation and analysis at the event level. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidoMidiFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using mido, with details about the specific error. \"\"\" try : return MidoMidiFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with Mido: { str ( e ) } \" ) Functions load_midi_toolkit ( midi_bytes : bytes ) -> MidiToolkitFile Load a MIDI file using the miditoolkit library. This method converts raw bytes into a MidiToolkitFile object, which provides comprehensive capabilities for MIDI manipulation, including note extraction, tempo and time signature analysis, and more. Parameters: midi_bytes ( bytes ) \u2013 Raw MIDI file data as bytes. Returns: MidiFile \u2013 A MidiToolkitFile object representing the loaded MIDI file. Raises: ValueError \u2013 If the MIDI file cannot be loaded using miditoolkit, with details about the specific error. Source code in backend/core/service/midi/midi_loader.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def load_midi_toolkit ( self , midi_bytes : bytes ) -> MidiToolkitFile : \"\"\" Load a MIDI file using the miditoolkit library. This method converts raw bytes into a MidiToolkitFile object, which provides comprehensive capabilities for MIDI manipulation, including note extraction, tempo and time signature analysis, and more. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidiToolkitFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using miditoolkit, with details about the specific error. \"\"\" try : return MidiToolkitFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with MidiToolkit: { str ( e ) } \" ) load_mido_midi ( midi_bytes : bytes ) -> MidoMidiFile Load a MIDI file using the mido library. This method converts raw bytes into a MidoMidiFile object, which provides low-level access to MIDI messages and is useful for MIDI message manipulation and analysis at the event level. Parameters: midi_bytes ( bytes ) \u2013 Raw MIDI file data as bytes. Returns: MidiFile \u2013 A MidoMidiFile object representing the loaded MIDI file. Raises: ValueError \u2013 If the MIDI file cannot be loaded using mido, with details about the specific error. Source code in backend/core/service/midi/midi_loader.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def load_mido_midi ( self , midi_bytes : bytes ) -> MidoMidiFile : \"\"\" Load a MIDI file using the mido library. This method converts raw bytes into a MidoMidiFile object, which provides low-level access to MIDI messages and is useful for MIDI message manipulation and analysis at the event level. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidoMidiFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using mido, with details about the specific error. \"\"\" try : return MidoMidiFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with Mido: { str ( e ) } \" )","title":"MIDI Loader Class"},{"location":"Development%20documentation/service/MidiLoader/#midi-loader-class","text":"","title":"MIDI Loader Class"},{"location":"Development%20documentation/service/MidiLoader/#backend.core.service.midi.midi_loader-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/MidiLoader/#backend.core.service.midi.midi_loader.MidiLoader","text":"Utility class for loading MIDI files using different MIDI processing libraries. This class provides methods to load MIDI data using both miditoolkit and mido libraries, which offer different capabilities for MIDI file manipulation and analysis. The class handles the conversion of raw bytes to MIDI objects that can be processed by these libraries. Source code in backend/core/service/midi/midi_loader.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MidiLoader : \"\"\" Utility class for loading MIDI files using different MIDI processing libraries. This class provides methods to load MIDI data using both miditoolkit and mido libraries, which offer different capabilities for MIDI file manipulation and analysis. The class handles the conversion of raw bytes to MIDI objects that can be processed by these libraries. \"\"\" def __init__ ( self ): pass def load_midi_toolkit ( self , midi_bytes : bytes ) -> MidiToolkitFile : \"\"\" Load a MIDI file using the miditoolkit library. This method converts raw bytes into a MidiToolkitFile object, which provides comprehensive capabilities for MIDI manipulation, including note extraction, tempo and time signature analysis, and more. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidiToolkitFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using miditoolkit, with details about the specific error. \"\"\" try : return MidiToolkitFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with MidiToolkit: { str ( e ) } \" ) def load_mido_midi ( self , midi_bytes : bytes ) -> MidoMidiFile : \"\"\" Load a MIDI file using the mido library. This method converts raw bytes into a MidoMidiFile object, which provides low-level access to MIDI messages and is useful for MIDI message manipulation and analysis at the event level. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidoMidiFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using mido, with details about the specific error. \"\"\" try : return MidoMidiFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with Mido: { str ( e ) } \" )","title":"MidiLoader"},{"location":"Development%20documentation/service/MidiLoader/#backend.core.service.midi.midi_loader.MidiLoader-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/MidiLoader/#backend.core.service.midi.midi_loader.MidiLoader.load_midi_toolkit","text":"Load a MIDI file using the miditoolkit library. This method converts raw bytes into a MidiToolkitFile object, which provides comprehensive capabilities for MIDI manipulation, including note extraction, tempo and time signature analysis, and more. Parameters: midi_bytes ( bytes ) \u2013 Raw MIDI file data as bytes. Returns: MidiFile \u2013 A MidiToolkitFile object representing the loaded MIDI file. Raises: ValueError \u2013 If the MIDI file cannot be loaded using miditoolkit, with details about the specific error. Source code in backend/core/service/midi/midi_loader.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def load_midi_toolkit ( self , midi_bytes : bytes ) -> MidiToolkitFile : \"\"\" Load a MIDI file using the miditoolkit library. This method converts raw bytes into a MidiToolkitFile object, which provides comprehensive capabilities for MIDI manipulation, including note extraction, tempo and time signature analysis, and more. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidiToolkitFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using miditoolkit, with details about the specific error. \"\"\" try : return MidiToolkitFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with MidiToolkit: { str ( e ) } \" )","title":"load_midi_toolkit"},{"location":"Development%20documentation/service/MidiLoader/#backend.core.service.midi.midi_loader.MidiLoader.load_mido_midi","text":"Load a MIDI file using the mido library. This method converts raw bytes into a MidoMidiFile object, which provides low-level access to MIDI messages and is useful for MIDI message manipulation and analysis at the event level. Parameters: midi_bytes ( bytes ) \u2013 Raw MIDI file data as bytes. Returns: MidiFile \u2013 A MidoMidiFile object representing the loaded MIDI file. Raises: ValueError \u2013 If the MIDI file cannot be loaded using mido, with details about the specific error. Source code in backend/core/service/midi/midi_loader.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def load_mido_midi ( self , midi_bytes : bytes ) -> MidoMidiFile : \"\"\" Load a MIDI file using the mido library. This method converts raw bytes into a MidoMidiFile object, which provides low-level access to MIDI messages and is useful for MIDI message manipulation and analysis at the event level. Args: midi_bytes: Raw MIDI file data as bytes. Returns: A MidoMidiFile object representing the loaded MIDI file. Raises: ValueError: If the MIDI file cannot be loaded using mido, with details about the specific error. \"\"\" try : return MidoMidiFile ( file = BytesIO ( midi_bytes )) except Exception as e : raise ValueError ( f \"Failed to load MIDI file with Mido: { str ( e ) } \" )","title":"load_mido_midi"},{"location":"Development%20documentation/service/MidiProcessing/","text":"MIDI Processing Classes MidiProcessor Source code in backend/core/service/midi_processing.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class MidiProcessor : def __init__ ( self , user_config : ConfigModel = None ): \"\"\" Initializes the MidiProcessor with required components. \"\"\" self . user_config = user_config self . loader = MidiLoader () self . tokenizer_factory = TokenizerFactory () self . note_extractor = NoteExtractor () self . note_id_handler = NoteIDHandler () self . midi_info_extractor = MidiInformationExtractor () def tokenize_midi_file ( self , user_config : ConfigModel , midi_bytes : bytes ) -> tuple [ Any , list [ list [ Note ]]]: \"\"\" Tokenizes a MIDI file based on user configuration. Args: user_config: Configuration model with tokenization parameters midi_bytes: Raw bytes of the MIDI file Returns: Tuple containing tokenized MIDI and extracted notes \"\"\" tokenizer_config_user = TokenizerConfigUser ( user_config ) tokenizer_config = TokenizerConfig ( ** tokenizer_config_user . get_params ()) tokenizer = self . tokenizer_factory . get_tokenizer ( user_config . tokenizer , tokenizer_config ) midi = self . loader . load_midi_toolkit ( midi_bytes ) tokens = tokenizer ( midi ) notes = self . note_extractor . midi_to_notes ( midi ) tokens = self . note_id_handler . add_notes_id ( tokens , notes , user_config . tokenizer , user_config . use_programs , user_config . base_tokenizer ) return tokens , notes def retrieve_information_from_midi ( self , midi_bytes : bytes ) -> MusicInformationData : \"\"\" Extracts musical information from a MIDI file. Args: midi_bytes: Raw bytes of the MIDI file Returns: MusicInformationData containing extracted information Raises: ValueError: If music information data could not be processed \"\"\" midi = self . loader . load_mido_midi ( midi_bytes ) midi_file_music = muspy . from_mido ( midi ) return self . midi_info_extractor . extract_information ( midi_file_music ) Functions __init__ ( user_config : ConfigModel = None ) Initializes the MidiProcessor with required components. Source code in backend/core/service/midi_processing.py 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , user_config : ConfigModel = None ): \"\"\" Initializes the MidiProcessor with required components. \"\"\" self . user_config = user_config self . loader = MidiLoader () self . tokenizer_factory = TokenizerFactory () self . note_extractor = NoteExtractor () self . note_id_handler = NoteIDHandler () self . midi_info_extractor = MidiInformationExtractor () tokenize_midi_file ( user_config : ConfigModel , midi_bytes : bytes ) -> tuple [ Any , list [ list [ Note ]]] Tokenizes a MIDI file based on user configuration. Parameters: user_config ( ConfigModel ) \u2013 Configuration model with tokenization parameters midi_bytes ( bytes ) \u2013 Raw bytes of the MIDI file Returns: tuple [ Any , list [ list [ Note ]]] \u2013 Tuple containing tokenized MIDI and extracted notes Source code in backend/core/service/midi_processing.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tokenize_midi_file ( self , user_config : ConfigModel , midi_bytes : bytes ) -> tuple [ Any , list [ list [ Note ]]]: \"\"\" Tokenizes a MIDI file based on user configuration. Args: user_config: Configuration model with tokenization parameters midi_bytes: Raw bytes of the MIDI file Returns: Tuple containing tokenized MIDI and extracted notes \"\"\" tokenizer_config_user = TokenizerConfigUser ( user_config ) tokenizer_config = TokenizerConfig ( ** tokenizer_config_user . get_params ()) tokenizer = self . tokenizer_factory . get_tokenizer ( user_config . tokenizer , tokenizer_config ) midi = self . loader . load_midi_toolkit ( midi_bytes ) tokens = tokenizer ( midi ) notes = self . note_extractor . midi_to_notes ( midi ) tokens = self . note_id_handler . add_notes_id ( tokens , notes , user_config . tokenizer , user_config . use_programs , user_config . base_tokenizer ) return tokens , notes retrieve_information_from_midi ( midi_bytes : bytes ) -> MusicInformationData Extracts musical information from a MIDI file. Parameters: midi_bytes ( bytes ) \u2013 Raw bytes of the MIDI file Returns: MusicInformationData \u2013 MusicInformationData containing extracted information Raises: ValueError \u2013 If music information data could not be processed Source code in backend/core/service/midi_processing.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def retrieve_information_from_midi ( self , midi_bytes : bytes ) -> MusicInformationData : \"\"\" Extracts musical information from a MIDI file. Args: midi_bytes: Raw bytes of the MIDI file Returns: MusicInformationData containing extracted information Raises: ValueError: If music information data could not be processed \"\"\" midi = self . loader . load_mido_midi ( midi_bytes ) midi_file_music = muspy . from_mido ( midi ) return self . midi_info_extractor . extract_information ( midi_file_music )","title":"MIDI Processing"},{"location":"Development%20documentation/service/MidiProcessing/#midi-processing","text":"","title":"MIDI Processing"},{"location":"Development%20documentation/service/MidiProcessing/#backend.core.service.midi_processing-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/MidiProcessing/#backend.core.service.midi_processing.MidiProcessor","text":"Source code in backend/core/service/midi_processing.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class MidiProcessor : def __init__ ( self , user_config : ConfigModel = None ): \"\"\" Initializes the MidiProcessor with required components. \"\"\" self . user_config = user_config self . loader = MidiLoader () self . tokenizer_factory = TokenizerFactory () self . note_extractor = NoteExtractor () self . note_id_handler = NoteIDHandler () self . midi_info_extractor = MidiInformationExtractor () def tokenize_midi_file ( self , user_config : ConfigModel , midi_bytes : bytes ) -> tuple [ Any , list [ list [ Note ]]]: \"\"\" Tokenizes a MIDI file based on user configuration. Args: user_config: Configuration model with tokenization parameters midi_bytes: Raw bytes of the MIDI file Returns: Tuple containing tokenized MIDI and extracted notes \"\"\" tokenizer_config_user = TokenizerConfigUser ( user_config ) tokenizer_config = TokenizerConfig ( ** tokenizer_config_user . get_params ()) tokenizer = self . tokenizer_factory . get_tokenizer ( user_config . tokenizer , tokenizer_config ) midi = self . loader . load_midi_toolkit ( midi_bytes ) tokens = tokenizer ( midi ) notes = self . note_extractor . midi_to_notes ( midi ) tokens = self . note_id_handler . add_notes_id ( tokens , notes , user_config . tokenizer , user_config . use_programs , user_config . base_tokenizer ) return tokens , notes def retrieve_information_from_midi ( self , midi_bytes : bytes ) -> MusicInformationData : \"\"\" Extracts musical information from a MIDI file. Args: midi_bytes: Raw bytes of the MIDI file Returns: MusicInformationData containing extracted information Raises: ValueError: If music information data could not be processed \"\"\" midi = self . loader . load_mido_midi ( midi_bytes ) midi_file_music = muspy . from_mido ( midi ) return self . midi_info_extractor . extract_information ( midi_file_music )","title":"MidiProcessor"},{"location":"Development%20documentation/service/MidiProcessing/#backend.core.service.midi_processing.MidiProcessor-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/MidiProcessing/#backend.core.service.midi_processing.MidiProcessor.__init__","text":"Initializes the MidiProcessor with required components. Source code in backend/core/service/midi_processing.py 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , user_config : ConfigModel = None ): \"\"\" Initializes the MidiProcessor with required components. \"\"\" self . user_config = user_config self . loader = MidiLoader () self . tokenizer_factory = TokenizerFactory () self . note_extractor = NoteExtractor () self . note_id_handler = NoteIDHandler () self . midi_info_extractor = MidiInformationExtractor ()","title":"__init__"},{"location":"Development%20documentation/service/MidiProcessing/#backend.core.service.midi_processing.MidiProcessor.tokenize_midi_file","text":"Tokenizes a MIDI file based on user configuration. Parameters: user_config ( ConfigModel ) \u2013 Configuration model with tokenization parameters midi_bytes ( bytes ) \u2013 Raw bytes of the MIDI file Returns: tuple [ Any , list [ list [ Note ]]] \u2013 Tuple containing tokenized MIDI and extracted notes Source code in backend/core/service/midi_processing.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def tokenize_midi_file ( self , user_config : ConfigModel , midi_bytes : bytes ) -> tuple [ Any , list [ list [ Note ]]]: \"\"\" Tokenizes a MIDI file based on user configuration. Args: user_config: Configuration model with tokenization parameters midi_bytes: Raw bytes of the MIDI file Returns: Tuple containing tokenized MIDI and extracted notes \"\"\" tokenizer_config_user = TokenizerConfigUser ( user_config ) tokenizer_config = TokenizerConfig ( ** tokenizer_config_user . get_params ()) tokenizer = self . tokenizer_factory . get_tokenizer ( user_config . tokenizer , tokenizer_config ) midi = self . loader . load_midi_toolkit ( midi_bytes ) tokens = tokenizer ( midi ) notes = self . note_extractor . midi_to_notes ( midi ) tokens = self . note_id_handler . add_notes_id ( tokens , notes , user_config . tokenizer , user_config . use_programs , user_config . base_tokenizer ) return tokens , notes","title":"tokenize_midi_file"},{"location":"Development%20documentation/service/MidiProcessing/#backend.core.service.midi_processing.MidiProcessor.retrieve_information_from_midi","text":"Extracts musical information from a MIDI file. Parameters: midi_bytes ( bytes ) \u2013 Raw bytes of the MIDI file Returns: MusicInformationData \u2013 MusicInformationData containing extracted information Raises: ValueError \u2013 If music information data could not be processed Source code in backend/core/service/midi_processing.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def retrieve_information_from_midi ( self , midi_bytes : bytes ) -> MusicInformationData : \"\"\" Extracts musical information from a MIDI file. Args: midi_bytes: Raw bytes of the MIDI file Returns: MusicInformationData containing extracted information Raises: ValueError: If music information data could not be processed \"\"\" midi = self . loader . load_mido_midi ( midi_bytes ) midi_file_music = muspy . from_mido ( midi ) return self . midi_info_extractor . extract_information ( midi_file_music )","title":"retrieve_information_from_midi"},{"location":"Development%20documentation/service/NoteExtractor/","text":"Note Extractor Classes NoteExtractor Utility class for extracting note information from MIDI files. This class provides functionality to convert MIDI files into structured Note objects that contain detailed information about each note in the file, including pitch, note name, start time, end time, and velocity. Source code in backend/core/service/note/note_extractor.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class NoteExtractor : \"\"\" Utility class for extracting note information from MIDI files. This class provides functionality to convert MIDI files into structured Note objects that contain detailed information about each note in the file, including pitch, note name, start time, end time, and velocity. \"\"\" def __init__ ( self ): pass def midi_to_notes ( self , midi : MidiToolkitFile ) -> List [ List [ Note ]]: \"\"\" Converts a MIDI file to a list of notes by track Args: midi: A MidiToolkitFile object Returns: A list of lists of Note objects, organized by track \"\"\" notes = [] for instrument in midi . instruments : track_notes = [] for note in instrument . notes : note_name = self . _pitch_to_name ( note . pitch ) track_notes . append ( Note ( note . pitch , note_name , note . start , note . end , note . velocity ) ) notes . append ( track_notes ) return notes @staticmethod def _pitch_to_name ( pitch : int ) -> str : \"\"\" Converts a MIDI pitch to a note name Args: pitch: MIDI pitch value Returns: String representation of the note (e.g., \"C4\") \"\"\" note_names = [ \"C\" , \"C#\" , \"D\" , \"D#\" , \"E\" , \"F\" , \"F#\" , \"G\" , \"G#\" , \"A\" , \"A#\" , \"B\" ] octave = pitch // 12 - 1 note = note_names [ pitch % 12 ] return f \" { note }{ octave } \" Functions midi_to_notes ( midi : MidiToolkitFile ) -> List [ List [ Note ]] Converts a MIDI file to a list of notes by track Parameters: midi ( MidiFile ) \u2013 A MidiToolkitFile object Returns: List [ List [ Note ]] \u2013 A list of lists of Note objects, organized by track Source code in backend/core/service/note/note_extractor.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def midi_to_notes ( self , midi : MidiToolkitFile ) -> List [ List [ Note ]]: \"\"\" Converts a MIDI file to a list of notes by track Args: midi: A MidiToolkitFile object Returns: A list of lists of Note objects, organized by track \"\"\" notes = [] for instrument in midi . instruments : track_notes = [] for note in instrument . notes : note_name = self . _pitch_to_name ( note . pitch ) track_notes . append ( Note ( note . pitch , note_name , note . start , note . end , note . velocity ) ) notes . append ( track_notes ) return notes","title":"Note Extractor"},{"location":"Development%20documentation/service/NoteExtractor/#note-extractor","text":"","title":"Note Extractor"},{"location":"Development%20documentation/service/NoteExtractor/#backend.core.service.note.note_extractor-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/NoteExtractor/#backend.core.service.note.note_extractor.NoteExtractor","text":"Utility class for extracting note information from MIDI files. This class provides functionality to convert MIDI files into structured Note objects that contain detailed information about each note in the file, including pitch, note name, start time, end time, and velocity. Source code in backend/core/service/note/note_extractor.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class NoteExtractor : \"\"\" Utility class for extracting note information from MIDI files. This class provides functionality to convert MIDI files into structured Note objects that contain detailed information about each note in the file, including pitch, note name, start time, end time, and velocity. \"\"\" def __init__ ( self ): pass def midi_to_notes ( self , midi : MidiToolkitFile ) -> List [ List [ Note ]]: \"\"\" Converts a MIDI file to a list of notes by track Args: midi: A MidiToolkitFile object Returns: A list of lists of Note objects, organized by track \"\"\" notes = [] for instrument in midi . instruments : track_notes = [] for note in instrument . notes : note_name = self . _pitch_to_name ( note . pitch ) track_notes . append ( Note ( note . pitch , note_name , note . start , note . end , note . velocity ) ) notes . append ( track_notes ) return notes @staticmethod def _pitch_to_name ( pitch : int ) -> str : \"\"\" Converts a MIDI pitch to a note name Args: pitch: MIDI pitch value Returns: String representation of the note (e.g., \"C4\") \"\"\" note_names = [ \"C\" , \"C#\" , \"D\" , \"D#\" , \"E\" , \"F\" , \"F#\" , \"G\" , \"G#\" , \"A\" , \"A#\" , \"B\" ] octave = pitch // 12 - 1 note = note_names [ pitch % 12 ] return f \" { note }{ octave } \"","title":"NoteExtractor"},{"location":"Development%20documentation/service/NoteExtractor/#backend.core.service.note.note_extractor.NoteExtractor-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/NoteExtractor/#backend.core.service.note.note_extractor.NoteExtractor.midi_to_notes","text":"Converts a MIDI file to a list of notes by track Parameters: midi ( MidiFile ) \u2013 A MidiToolkitFile object Returns: List [ List [ Note ]] \u2013 A list of lists of Note objects, organized by track Source code in backend/core/service/note/note_extractor.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def midi_to_notes ( self , midi : MidiToolkitFile ) -> List [ List [ Note ]]: \"\"\" Converts a MIDI file to a list of notes by track Args: midi: A MidiToolkitFile object Returns: A list of lists of Note objects, organized by track \"\"\" notes = [] for instrument in midi . instruments : track_notes = [] for note in instrument . notes : note_name = self . _pitch_to_name ( note . pitch ) track_notes . append ( Note ( note . pitch , note_name , note . start , note . end , note . velocity ) ) notes . append ( track_notes ) return notes","title":"midi_to_notes"},{"location":"Development%20documentation/service/NoteId/","text":"Note ID Classes NoteIDHandler Handles assigning note and track IDs to tokens in MIDI processing pipeline. This class is responsible for tracking and assigning unique identifiers to notes and tokens in processed MIDI data. It supports various tokenization schemes and can operate in both normal mode and programs mode depending on the configuration. Attributes: current_note_id \u2013 The ID of the currently processed note current_track_id \u2013 The ID of the current track being processed i \u2013 Counter used to track position in notes collection active_notes \u2013 Dictionary tracking active notes (for MIDILike tokenizer) Source code in backend/core/service/note/note_id.py 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 class NoteIDHandler : \"\"\" Handles assigning note and track IDs to tokens in MIDI processing pipeline. This class is responsible for tracking and assigning unique identifiers to notes and tokens in processed MIDI data. It supports various tokenization schemes and can operate in both normal mode and programs mode depending on the configuration. Attributes: current_note_id: The ID of the currently processed note current_track_id: The ID of the current track being processed i: Counter used to track position in notes collection active_notes: Dictionary tracking active notes (for MIDILike tokenizer) \"\"\" def __init__ ( self ): self . current_note_id = None self . current_track_id = 0 self . i = - 1 self . active_notes = {} def add_notes_id ( self , tokens , notes , tokenizer , use_programs = False , base_tokenizer = None ): \"\"\" Assigns note and track IDs to tokens. Args: tokens: Tokens to process notes: List of notes from MIDI file tokenizer: Tokenizer type (\"REMI\", \"CPWord\", etc.) use_programs: Whether to use programs mode Returns: Processed tokens with assigned IDs \"\"\" self . _prepare_note_mappings ( notes ) if use_programs : handlers = { \"REMI\" : self . _process_tokens_REMI_use_programs , \"Structured\" : self . _process_tokens_REMI_use_programs , \"TSD\" : self . _process_tokens_REMI_use_programs , \"CPWord\" : self . _process_tokens_CPWord_use_programs , \"MIDILike\" : self . _process_tokens_MIDILike_use_programs , } else : handlers = { \"REMI\" : self . _process_tokens_REMI , \"PerTok\" : self . _process_tokens_REMI , \"Structured\" : self . _process_tokens_REMI , \"TSD\" : self . _process_tokens_REMI , \"CPWord\" : self . _process_tokens_CPWord , \"MIDILike\" : self . _process_tokens_MIDILike , \"Octuple\" : self . _process_tokens_Octuple , \"MuMIDI\" : self . _process_tokens_MuMIDI , \"MMM\" : lambda t : self . _process_tokens_MMM ( t , base_tokenizer ) } if tokenizer not in handlers : raise ValueError ( f \"Unsupported tokenizer: { tokenizer } with use_programs= { use_programs } \" ) if tokenizer == \"MuMIDI\" and not use_programs : tokens = self . _add_events_to_mumidi ( tokens ) return handlers [ tokenizer ]( tokens ) def _prepare_note_mappings ( self , notes ): \"\"\"Prepares mappings for note and track IDs\"\"\" tracks_len = [ len ( row ) for row in notes ] self . notes_ids = list ( range ( sum ( tracks_len ))) self . note_to_track = [ track_id for track_id , l in enumerate ( tracks_len ) for _ in range ( l )] def _set_non_pitch_attributes ( self , token ): \"\"\"Sets attributes for non-Pitch tokens\"\"\" if token . type_ in [ \"Velocity\" , \"Duration\" , \"MicroTiming\" ]: token . note_id = self . current_note_id if not self . current_note_id : print ( \"Warning: current_note_id is None!\" ) else : token . note_id = None def _update_note_and_track_ids ( self ): \"\"\"Updates current note and track IDs\"\"\" self . current_note_id = self . notes_ids [ self . i ] + 1 self . current_track_id = self . note_to_track [ self . i ] def _increment_counter ( self ): \"\"\"Increments note counter\"\"\" self . i += 1 def _reset_counters ( self ): \"\"\"Resets counters and current IDs\"\"\" self . i = - 1 self . current_note_id = None self . current_track_id = 0 def _process_tokens_REMI ( self , tokens ): \"\"\"Processes REMI tokens without use_programs\"\"\" self . _reset_counters () for token_list in tokens : for token in token_list . events : token . track_id = self . current_track_id if token . type_ in [ \"Pitch\" , \"PitchDrum\" ]: self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id else : self . _set_non_pitch_attributes ( token ) return tokens def _process_tokens_CPWord ( self , tokens ): \"\"\"Processes CPWord tokens without use_programs\"\"\" self . _reset_counters () for token_list in tokens : for compound_token in token_list . events : if compound_token [ 0 ] . value == \"Note\" : for token in compound_token : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id if token . type_ in [ \"Pitch\" , \"Velocity\" , \"Duration\" ] else None token . track_id = self . current_track_id return tokens def _process_tokens_MIDILike ( self , tokens ): \"\"\"Processes MIDILike tokens without use_programs\"\"\" self . _reset_counters () self . active_notes = {} for token_list in tokens : for token in token_list . events : if token . type_ == \"NoteOn\" : self . _increment_counter () self . _update_note_and_track_ids () self . active_notes [ token . value ] = ( self . current_note_id , self . current_track_id ) token . note_id , token . track_id = self . current_note_id , self . current_track_id elif token . type_ == \"Velocity\" : token . note_id , token . track_id = self . current_note_id , self . current_track_id elif token . type_ == \"NoteOff\" : note_info = self . active_notes . pop ( token . value , ( None , self . current_track_id )) token . note_id , token . track_id = note_info self . current_note_id = None else : token . note_id , token . track_id = None , self . current_track_id return tokens def _process_tokens_Octuple ( self , tokens ): \"\"\"Processes Octuple tokens without use_programs\"\"\" self . _reset_counters () for token_list in tokens : for compound_token in token_list . events : if compound_token [ 0 ] . type_ in [ \"Pitch\" , \"PitchDrum\" ]: for token in compound_token : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id if token . type_ in [ \"Pitch\" , \"Velocity\" , \"Duration\" , \"Position\" , \"Bar\" ] else None token . track_id = self . current_track_id return tokens def _process_tokens_REMI_use_programs ( self , tokens ): \"\"\"Processes REMI tokens with use_programs\"\"\" self . _reset_counters () for token in tokens . events : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" , \"MicroTiming\" ]: if self . current_note_id is not None : token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None return tokens def _process_tokens_CPWord_use_programs ( self , tokens ): \"\"\"Processes CPWord tokens with use_programs\"\"\" self . _reset_counters () for token_list in tokens . events : for token in token_list : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" ]: if self . current_note_id is not None : token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id return tokens def _process_tokens_MIDILike_use_programs ( self , tokens ): \"\"\"Processes MIDILike tokens with use_programs\"\"\" self . _reset_counters () self . active_notes = {} for token in tokens . events : if token . type_ == \"NoteOn\" : self . _increment_counter () self . _update_note_and_track_ids () self . active_notes [ token . value ] = self . current_note_id token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ == \"Velocity\" : if self . current_note_id : token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ == \"NoteOff\" : if token . value in self . active_notes : token . note_id = self . active_notes . pop ( token . value ) token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id self . current_note_id = None else : token . note_id = None token . track_id = self . current_track_id return tokens # New methods for MuMIDI and MMM tokenizers def _add_events_to_mumidi ( self , tokens ): \"\"\" MuMIDI tokenizer does not have the events attribute assigned by MIDITok's library. This method creates events from tokens attribute. \"\"\" tokens . events = [] for token_list in tokens . tokens : event_list = [] for token in token_list : type_ = token . split ( \"_\" )[ 0 ] value = token . split ( \"_\" )[ 1 ] # Create Event object with type and value event_list . append ( Event ( type_ , value )) tokens . events . append ( event_list ) return tokens def _process_tokens_MuMIDI ( self , tokens ): \"\"\"Processes MuMIDI tokens\"\"\" self . _reset_counters () for token_list in tokens . events : for token in token_list : if token . type_ in [ \"Pitch\" , \"PitchDrum\" ]: self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" ]: if self . current_note_id is None : import warnings warnings . warn ( \"Warning: current_note_id is None!\" ) continue token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id return tokens def _process_tokens_MMM ( self , tokens , base_tokenizer ): \"\"\" Processes MMM tokens using a base tokenizer Args: tokens: Tokens to process base_tokenizer: Base tokenizer type used by MMM Returns: Processed tokens with assigned IDs \"\"\" if base_tokenizer is None : raise ValueError ( \"MMM tokenizers must have a specified base tokenizer!\" ) self . _reset_counters () if base_tokenizer == \"MIDILike\" : for token in tokens . events : if token . type_ in [ \"NoteOn\" , \"DrumOn\" ]: self . _increment_counter () self . _update_note_and_track_ids () self . active_notes [ token . value ] = self . current_note_id token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ == \"Velocity\" : if self . current_note_id : token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"NoteOff\" , \"DrumOff\" ]: if token . value in self . active_notes : token . note_id = self . active_notes . pop ( token . value ) token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id self . current_note_id = None else : token . note_id = None token . track_id = self . current_track_id elif base_tokenizer in [ \"REMI\" , \"TSD\" ]: for token in tokens . events : if token . type_ in [ \"Pitch\" , \"PitchDrum\" ]: self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" ]: if self . current_note_id is None : import warnings warnings . warn ( \"Warning: current_note_id is None!\" ) continue token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id else : raise ValueError ( f \" { base_tokenizer } is NOT a supported base tokenizer for MMM!\" ) return tokens Functions add_notes_id ( tokens , notes , tokenizer , use_programs = False , base_tokenizer = None ) Assigns note and track IDs to tokens. Parameters: tokens \u2013 Tokens to process notes \u2013 List of notes from MIDI file tokenizer \u2013 Tokenizer type (\"REMI\", \"CPWord\", etc.) use_programs \u2013 Whether to use programs mode Returns: \u2013 Processed tokens with assigned IDs Source code in backend/core/service/note/note_id.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def add_notes_id ( self , tokens , notes , tokenizer , use_programs = False , base_tokenizer = None ): \"\"\" Assigns note and track IDs to tokens. Args: tokens: Tokens to process notes: List of notes from MIDI file tokenizer: Tokenizer type (\"REMI\", \"CPWord\", etc.) use_programs: Whether to use programs mode Returns: Processed tokens with assigned IDs \"\"\" self . _prepare_note_mappings ( notes ) if use_programs : handlers = { \"REMI\" : self . _process_tokens_REMI_use_programs , \"Structured\" : self . _process_tokens_REMI_use_programs , \"TSD\" : self . _process_tokens_REMI_use_programs , \"CPWord\" : self . _process_tokens_CPWord_use_programs , \"MIDILike\" : self . _process_tokens_MIDILike_use_programs , } else : handlers = { \"REMI\" : self . _process_tokens_REMI , \"PerTok\" : self . _process_tokens_REMI , \"Structured\" : self . _process_tokens_REMI , \"TSD\" : self . _process_tokens_REMI , \"CPWord\" : self . _process_tokens_CPWord , \"MIDILike\" : self . _process_tokens_MIDILike , \"Octuple\" : self . _process_tokens_Octuple , \"MuMIDI\" : self . _process_tokens_MuMIDI , \"MMM\" : lambda t : self . _process_tokens_MMM ( t , base_tokenizer ) } if tokenizer not in handlers : raise ValueError ( f \"Unsupported tokenizer: { tokenizer } with use_programs= { use_programs } \" ) if tokenizer == \"MuMIDI\" and not use_programs : tokens = self . _add_events_to_mumidi ( tokens ) return handlers [ tokenizer ]( tokens )","title":"Note ID"},{"location":"Development%20documentation/service/NoteId/#note-id","text":"","title":"Note ID"},{"location":"Development%20documentation/service/NoteId/#backend.core.service.note.note_id-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/NoteId/#backend.core.service.note.note_id.NoteIDHandler","text":"Handles assigning note and track IDs to tokens in MIDI processing pipeline. This class is responsible for tracking and assigning unique identifiers to notes and tokens in processed MIDI data. It supports various tokenization schemes and can operate in both normal mode and programs mode depending on the configuration. Attributes: current_note_id \u2013 The ID of the currently processed note current_track_id \u2013 The ID of the current track being processed i \u2013 Counter used to track position in notes collection active_notes \u2013 Dictionary tracking active notes (for MIDILike tokenizer) Source code in backend/core/service/note/note_id.py 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 class NoteIDHandler : \"\"\" Handles assigning note and track IDs to tokens in MIDI processing pipeline. This class is responsible for tracking and assigning unique identifiers to notes and tokens in processed MIDI data. It supports various tokenization schemes and can operate in both normal mode and programs mode depending on the configuration. Attributes: current_note_id: The ID of the currently processed note current_track_id: The ID of the current track being processed i: Counter used to track position in notes collection active_notes: Dictionary tracking active notes (for MIDILike tokenizer) \"\"\" def __init__ ( self ): self . current_note_id = None self . current_track_id = 0 self . i = - 1 self . active_notes = {} def add_notes_id ( self , tokens , notes , tokenizer , use_programs = False , base_tokenizer = None ): \"\"\" Assigns note and track IDs to tokens. Args: tokens: Tokens to process notes: List of notes from MIDI file tokenizer: Tokenizer type (\"REMI\", \"CPWord\", etc.) use_programs: Whether to use programs mode Returns: Processed tokens with assigned IDs \"\"\" self . _prepare_note_mappings ( notes ) if use_programs : handlers = { \"REMI\" : self . _process_tokens_REMI_use_programs , \"Structured\" : self . _process_tokens_REMI_use_programs , \"TSD\" : self . _process_tokens_REMI_use_programs , \"CPWord\" : self . _process_tokens_CPWord_use_programs , \"MIDILike\" : self . _process_tokens_MIDILike_use_programs , } else : handlers = { \"REMI\" : self . _process_tokens_REMI , \"PerTok\" : self . _process_tokens_REMI , \"Structured\" : self . _process_tokens_REMI , \"TSD\" : self . _process_tokens_REMI , \"CPWord\" : self . _process_tokens_CPWord , \"MIDILike\" : self . _process_tokens_MIDILike , \"Octuple\" : self . _process_tokens_Octuple , \"MuMIDI\" : self . _process_tokens_MuMIDI , \"MMM\" : lambda t : self . _process_tokens_MMM ( t , base_tokenizer ) } if tokenizer not in handlers : raise ValueError ( f \"Unsupported tokenizer: { tokenizer } with use_programs= { use_programs } \" ) if tokenizer == \"MuMIDI\" and not use_programs : tokens = self . _add_events_to_mumidi ( tokens ) return handlers [ tokenizer ]( tokens ) def _prepare_note_mappings ( self , notes ): \"\"\"Prepares mappings for note and track IDs\"\"\" tracks_len = [ len ( row ) for row in notes ] self . notes_ids = list ( range ( sum ( tracks_len ))) self . note_to_track = [ track_id for track_id , l in enumerate ( tracks_len ) for _ in range ( l )] def _set_non_pitch_attributes ( self , token ): \"\"\"Sets attributes for non-Pitch tokens\"\"\" if token . type_ in [ \"Velocity\" , \"Duration\" , \"MicroTiming\" ]: token . note_id = self . current_note_id if not self . current_note_id : print ( \"Warning: current_note_id is None!\" ) else : token . note_id = None def _update_note_and_track_ids ( self ): \"\"\"Updates current note and track IDs\"\"\" self . current_note_id = self . notes_ids [ self . i ] + 1 self . current_track_id = self . note_to_track [ self . i ] def _increment_counter ( self ): \"\"\"Increments note counter\"\"\" self . i += 1 def _reset_counters ( self ): \"\"\"Resets counters and current IDs\"\"\" self . i = - 1 self . current_note_id = None self . current_track_id = 0 def _process_tokens_REMI ( self , tokens ): \"\"\"Processes REMI tokens without use_programs\"\"\" self . _reset_counters () for token_list in tokens : for token in token_list . events : token . track_id = self . current_track_id if token . type_ in [ \"Pitch\" , \"PitchDrum\" ]: self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id else : self . _set_non_pitch_attributes ( token ) return tokens def _process_tokens_CPWord ( self , tokens ): \"\"\"Processes CPWord tokens without use_programs\"\"\" self . _reset_counters () for token_list in tokens : for compound_token in token_list . events : if compound_token [ 0 ] . value == \"Note\" : for token in compound_token : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id if token . type_ in [ \"Pitch\" , \"Velocity\" , \"Duration\" ] else None token . track_id = self . current_track_id return tokens def _process_tokens_MIDILike ( self , tokens ): \"\"\"Processes MIDILike tokens without use_programs\"\"\" self . _reset_counters () self . active_notes = {} for token_list in tokens : for token in token_list . events : if token . type_ == \"NoteOn\" : self . _increment_counter () self . _update_note_and_track_ids () self . active_notes [ token . value ] = ( self . current_note_id , self . current_track_id ) token . note_id , token . track_id = self . current_note_id , self . current_track_id elif token . type_ == \"Velocity\" : token . note_id , token . track_id = self . current_note_id , self . current_track_id elif token . type_ == \"NoteOff\" : note_info = self . active_notes . pop ( token . value , ( None , self . current_track_id )) token . note_id , token . track_id = note_info self . current_note_id = None else : token . note_id , token . track_id = None , self . current_track_id return tokens def _process_tokens_Octuple ( self , tokens ): \"\"\"Processes Octuple tokens without use_programs\"\"\" self . _reset_counters () for token_list in tokens : for compound_token in token_list . events : if compound_token [ 0 ] . type_ in [ \"Pitch\" , \"PitchDrum\" ]: for token in compound_token : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id if token . type_ in [ \"Pitch\" , \"Velocity\" , \"Duration\" , \"Position\" , \"Bar\" ] else None token . track_id = self . current_track_id return tokens def _process_tokens_REMI_use_programs ( self , tokens ): \"\"\"Processes REMI tokens with use_programs\"\"\" self . _reset_counters () for token in tokens . events : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" , \"MicroTiming\" ]: if self . current_note_id is not None : token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None return tokens def _process_tokens_CPWord_use_programs ( self , tokens ): \"\"\"Processes CPWord tokens with use_programs\"\"\" self . _reset_counters () for token_list in tokens . events : for token in token_list : if token . type_ == \"Pitch\" : self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" ]: if self . current_note_id is not None : token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id return tokens def _process_tokens_MIDILike_use_programs ( self , tokens ): \"\"\"Processes MIDILike tokens with use_programs\"\"\" self . _reset_counters () self . active_notes = {} for token in tokens . events : if token . type_ == \"NoteOn\" : self . _increment_counter () self . _update_note_and_track_ids () self . active_notes [ token . value ] = self . current_note_id token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ == \"Velocity\" : if self . current_note_id : token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ == \"NoteOff\" : if token . value in self . active_notes : token . note_id = self . active_notes . pop ( token . value ) token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id self . current_note_id = None else : token . note_id = None token . track_id = self . current_track_id return tokens # New methods for MuMIDI and MMM tokenizers def _add_events_to_mumidi ( self , tokens ): \"\"\" MuMIDI tokenizer does not have the events attribute assigned by MIDITok's library. This method creates events from tokens attribute. \"\"\" tokens . events = [] for token_list in tokens . tokens : event_list = [] for token in token_list : type_ = token . split ( \"_\" )[ 0 ] value = token . split ( \"_\" )[ 1 ] # Create Event object with type and value event_list . append ( Event ( type_ , value )) tokens . events . append ( event_list ) return tokens def _process_tokens_MuMIDI ( self , tokens ): \"\"\"Processes MuMIDI tokens\"\"\" self . _reset_counters () for token_list in tokens . events : for token in token_list : if token . type_ in [ \"Pitch\" , \"PitchDrum\" ]: self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" ]: if self . current_note_id is None : import warnings warnings . warn ( \"Warning: current_note_id is None!\" ) continue token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id return tokens def _process_tokens_MMM ( self , tokens , base_tokenizer ): \"\"\" Processes MMM tokens using a base tokenizer Args: tokens: Tokens to process base_tokenizer: Base tokenizer type used by MMM Returns: Processed tokens with assigned IDs \"\"\" if base_tokenizer is None : raise ValueError ( \"MMM tokenizers must have a specified base tokenizer!\" ) self . _reset_counters () if base_tokenizer == \"MIDILike\" : for token in tokens . events : if token . type_ in [ \"NoteOn\" , \"DrumOn\" ]: self . _increment_counter () self . _update_note_and_track_ids () self . active_notes [ token . value ] = self . current_note_id token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ == \"Velocity\" : if self . current_note_id : token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"NoteOff\" , \"DrumOff\" ]: if token . value in self . active_notes : token . note_id = self . active_notes . pop ( token . value ) token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id self . current_note_id = None else : token . note_id = None token . track_id = self . current_track_id elif base_tokenizer in [ \"REMI\" , \"TSD\" ]: for token in tokens . events : if token . type_ in [ \"Pitch\" , \"PitchDrum\" ]: self . _increment_counter () self . _update_note_and_track_ids () token . note_id = self . current_note_id token . track_id = self . current_track_id elif token . type_ in [ \"Velocity\" , \"Duration\" ]: if self . current_note_id is None : import warnings warnings . warn ( \"Warning: current_note_id is None!\" ) continue token . note_id = self . current_note_id token . track_id = self . current_track_id else : token . note_id = None token . track_id = self . current_track_id else : raise ValueError ( f \" { base_tokenizer } is NOT a supported base tokenizer for MMM!\" ) return tokens","title":"NoteIDHandler"},{"location":"Development%20documentation/service/NoteId/#backend.core.service.note.note_id.NoteIDHandler-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/NoteId/#backend.core.service.note.note_id.NoteIDHandler.add_notes_id","text":"Assigns note and track IDs to tokens. Parameters: tokens \u2013 Tokens to process notes \u2013 List of notes from MIDI file tokenizer \u2013 Tokenizer type (\"REMI\", \"CPWord\", etc.) use_programs \u2013 Whether to use programs mode Returns: \u2013 Processed tokens with assigned IDs Source code in backend/core/service/note/note_id.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def add_notes_id ( self , tokens , notes , tokenizer , use_programs = False , base_tokenizer = None ): \"\"\" Assigns note and track IDs to tokens. Args: tokens: Tokens to process notes: List of notes from MIDI file tokenizer: Tokenizer type (\"REMI\", \"CPWord\", etc.) use_programs: Whether to use programs mode Returns: Processed tokens with assigned IDs \"\"\" self . _prepare_note_mappings ( notes ) if use_programs : handlers = { \"REMI\" : self . _process_tokens_REMI_use_programs , \"Structured\" : self . _process_tokens_REMI_use_programs , \"TSD\" : self . _process_tokens_REMI_use_programs , \"CPWord\" : self . _process_tokens_CPWord_use_programs , \"MIDILike\" : self . _process_tokens_MIDILike_use_programs , } else : handlers = { \"REMI\" : self . _process_tokens_REMI , \"PerTok\" : self . _process_tokens_REMI , \"Structured\" : self . _process_tokens_REMI , \"TSD\" : self . _process_tokens_REMI , \"CPWord\" : self . _process_tokens_CPWord , \"MIDILike\" : self . _process_tokens_MIDILike , \"Octuple\" : self . _process_tokens_Octuple , \"MuMIDI\" : self . _process_tokens_MuMIDI , \"MMM\" : lambda t : self . _process_tokens_MMM ( t , base_tokenizer ) } if tokenizer not in handlers : raise ValueError ( f \"Unsupported tokenizer: { tokenizer } with use_programs= { use_programs } \" ) if tokenizer == \"MuMIDI\" and not use_programs : tokens = self . _add_events_to_mumidi ( tokens ) return handlers [ tokenizer ]( tokens )","title":"add_notes_id"},{"location":"Development%20documentation/service/TokenizerConfig/","text":"Tokenizer Config Classes TokenizerConfigUser Adapter class that converts a user-provided ConfigModel into the format expected by the tokenizer implementation. Source code in backend/core/service/tokenizer/tokenizer_config.py 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class TokenizerConfigUser : \"\"\" Adapter class that converts a user-provided ConfigModel into the format expected by the tokenizer implementation. \"\"\" def __init__ ( self , user_config : ConfigModel ): \"\"\" Initialize the TokenizerConfigUser with parameters from a user ConfigModel. Args: user_config: The user-provided configuration model containing tokenization parameters. \"\"\" self . pitch_range = tuple ( user_config . pitch_range ) self . beat_res = {( 0 , 4 ): 8 , ( 4 , 12 ): 4 } self . num_velocities = user_config . num_velocities self . special_tokens = user_config . special_tokens self . use_chords = user_config . use_chords self . use_rests = user_config . use_rests self . use_tempos = user_config . use_tempos self . use_time_signatures = user_config . use_time_signatures self . use_sustain_pedals = user_config . use_sustain_pedals self . use_pitch_bends = user_config . use_pitch_bends self . num_tempos = user_config . num_tempos self . tempo_range = tuple ( user_config . tempo_range ) self . log_tempos = user_config . log_tempos self . delete_equal_successive_tempo_changes = user_config . delete_equal_successive_tempo_changes self . sustain_pedal_duration = user_config . sustain_pedal_duration self . pitch_bend_range = user_config . pitch_bend_range self . delete_equal_successive_time_sig_changes = user_config . delete_equal_successive_time_sig_changes self . use_programs = user_config . use_programs self . use_microtiming = user_config . use_microtiming self . ticks_per_quarter = user_config . ticks_per_quarter self . max_microtiming_shift = user_config . max_microtiming_shift self . num_microtiming_bins = user_config . num_microtiming_bins # added for MMM self . base_tokenizer = user_config . base_tokenizer def get_params ( self ) -> dict : \"\"\" Get all configuration parameters as a dictionary. This method returns all the tokenizer configuration parameters in a dictionary format that can be passed to the tokenizer implementation. Returns: A dictionary containing all tokenizer configuration parameters. \"\"\" return { \"pitch_range\" : self . pitch_range , \"beat_res\" : self . beat_res , \"num_velocities\" : self . num_velocities , \"special_tokens\" : self . special_tokens , \"use_chords\" : self . use_chords , \"use_rests\" : self . use_rests , \"use_tempos\" : self . use_tempos , \"use_time_signatures\" : self . use_time_signatures , \"use_sustain_pedals\" : self . use_sustain_pedals , \"use_pitch_bends\" : self . use_pitch_bends , \"num_tempos\" : self . num_tempos , \"tempo_range\" : self . tempo_range , \"log_tempos\" : self . log_tempos , \"delete_equal_successive_tempo_changes\" : self . delete_equal_successive_tempo_changes , \"sustain_pedal_duration\" : self . sustain_pedal_duration , \"pitch_bend_range\" : self . pitch_bend_range , \"delete_equal_successive_time_sig_changes\" : self . delete_equal_successive_time_sig_changes , \"use_programs\" : self . use_programs , \"use_microtiming\" : self . use_microtiming , \"ticks_per_quarter\" : self . ticks_per_quarter , \"max_microtiming_shift\" : self . max_microtiming_shift , \"num_microtiming_bins\" : self . num_microtiming_bins , \"base_tokenizer\" : self . base_tokenizer , } Functions __init__ ( user_config : ConfigModel ) Initialize the TokenizerConfigUser with parameters from a user ConfigModel. Parameters: user_config ( ConfigModel ) \u2013 The user-provided configuration model containing tokenization parameters. Source code in backend/core/service/tokenizer/tokenizer_config.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , user_config : ConfigModel ): \"\"\" Initialize the TokenizerConfigUser with parameters from a user ConfigModel. Args: user_config: The user-provided configuration model containing tokenization parameters. \"\"\" self . pitch_range = tuple ( user_config . pitch_range ) self . beat_res = {( 0 , 4 ): 8 , ( 4 , 12 ): 4 } self . num_velocities = user_config . num_velocities self . special_tokens = user_config . special_tokens self . use_chords = user_config . use_chords self . use_rests = user_config . use_rests self . use_tempos = user_config . use_tempos self . use_time_signatures = user_config . use_time_signatures self . use_sustain_pedals = user_config . use_sustain_pedals self . use_pitch_bends = user_config . use_pitch_bends self . num_tempos = user_config . num_tempos self . tempo_range = tuple ( user_config . tempo_range ) self . log_tempos = user_config . log_tempos self . delete_equal_successive_tempo_changes = user_config . delete_equal_successive_tempo_changes self . sustain_pedal_duration = user_config . sustain_pedal_duration self . pitch_bend_range = user_config . pitch_bend_range self . delete_equal_successive_time_sig_changes = user_config . delete_equal_successive_time_sig_changes self . use_programs = user_config . use_programs self . use_microtiming = user_config . use_microtiming self . ticks_per_quarter = user_config . ticks_per_quarter self . max_microtiming_shift = user_config . max_microtiming_shift self . num_microtiming_bins = user_config . num_microtiming_bins # added for MMM self . base_tokenizer = user_config . base_tokenizer get_params () -> dict Get all configuration parameters as a dictionary. This method returns all the tokenizer configuration parameters in a dictionary format that can be passed to the tokenizer implementation. Returns: dict \u2013 A dictionary containing all tokenizer configuration parameters. Source code in backend/core/service/tokenizer/tokenizer_config.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def get_params ( self ) -> dict : \"\"\" Get all configuration parameters as a dictionary. This method returns all the tokenizer configuration parameters in a dictionary format that can be passed to the tokenizer implementation. Returns: A dictionary containing all tokenizer configuration parameters. \"\"\" return { \"pitch_range\" : self . pitch_range , \"beat_res\" : self . beat_res , \"num_velocities\" : self . num_velocities , \"special_tokens\" : self . special_tokens , \"use_chords\" : self . use_chords , \"use_rests\" : self . use_rests , \"use_tempos\" : self . use_tempos , \"use_time_signatures\" : self . use_time_signatures , \"use_sustain_pedals\" : self . use_sustain_pedals , \"use_pitch_bends\" : self . use_pitch_bends , \"num_tempos\" : self . num_tempos , \"tempo_range\" : self . tempo_range , \"log_tempos\" : self . log_tempos , \"delete_equal_successive_tempo_changes\" : self . delete_equal_successive_tempo_changes , \"sustain_pedal_duration\" : self . sustain_pedal_duration , \"pitch_bend_range\" : self . pitch_bend_range , \"delete_equal_successive_time_sig_changes\" : self . delete_equal_successive_time_sig_changes , \"use_programs\" : self . use_programs , \"use_microtiming\" : self . use_microtiming , \"ticks_per_quarter\" : self . ticks_per_quarter , \"max_microtiming_shift\" : self . max_microtiming_shift , \"num_microtiming_bins\" : self . num_microtiming_bins , \"base_tokenizer\" : self . base_tokenizer , }","title":"Tokenizer Config"},{"location":"Development%20documentation/service/TokenizerConfig/#tokenizer-config","text":"","title":"Tokenizer Config"},{"location":"Development%20documentation/service/TokenizerConfig/#backend.core.service.tokenizer.tokenizer_config-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/TokenizerConfig/#backend.core.service.tokenizer.tokenizer_config.TokenizerConfigUser","text":"Adapter class that converts a user-provided ConfigModel into the format expected by the tokenizer implementation. Source code in backend/core/service/tokenizer/tokenizer_config.py 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class TokenizerConfigUser : \"\"\" Adapter class that converts a user-provided ConfigModel into the format expected by the tokenizer implementation. \"\"\" def __init__ ( self , user_config : ConfigModel ): \"\"\" Initialize the TokenizerConfigUser with parameters from a user ConfigModel. Args: user_config: The user-provided configuration model containing tokenization parameters. \"\"\" self . pitch_range = tuple ( user_config . pitch_range ) self . beat_res = {( 0 , 4 ): 8 , ( 4 , 12 ): 4 } self . num_velocities = user_config . num_velocities self . special_tokens = user_config . special_tokens self . use_chords = user_config . use_chords self . use_rests = user_config . use_rests self . use_tempos = user_config . use_tempos self . use_time_signatures = user_config . use_time_signatures self . use_sustain_pedals = user_config . use_sustain_pedals self . use_pitch_bends = user_config . use_pitch_bends self . num_tempos = user_config . num_tempos self . tempo_range = tuple ( user_config . tempo_range ) self . log_tempos = user_config . log_tempos self . delete_equal_successive_tempo_changes = user_config . delete_equal_successive_tempo_changes self . sustain_pedal_duration = user_config . sustain_pedal_duration self . pitch_bend_range = user_config . pitch_bend_range self . delete_equal_successive_time_sig_changes = user_config . delete_equal_successive_time_sig_changes self . use_programs = user_config . use_programs self . use_microtiming = user_config . use_microtiming self . ticks_per_quarter = user_config . ticks_per_quarter self . max_microtiming_shift = user_config . max_microtiming_shift self . num_microtiming_bins = user_config . num_microtiming_bins # added for MMM self . base_tokenizer = user_config . base_tokenizer def get_params ( self ) -> dict : \"\"\" Get all configuration parameters as a dictionary. This method returns all the tokenizer configuration parameters in a dictionary format that can be passed to the tokenizer implementation. Returns: A dictionary containing all tokenizer configuration parameters. \"\"\" return { \"pitch_range\" : self . pitch_range , \"beat_res\" : self . beat_res , \"num_velocities\" : self . num_velocities , \"special_tokens\" : self . special_tokens , \"use_chords\" : self . use_chords , \"use_rests\" : self . use_rests , \"use_tempos\" : self . use_tempos , \"use_time_signatures\" : self . use_time_signatures , \"use_sustain_pedals\" : self . use_sustain_pedals , \"use_pitch_bends\" : self . use_pitch_bends , \"num_tempos\" : self . num_tempos , \"tempo_range\" : self . tempo_range , \"log_tempos\" : self . log_tempos , \"delete_equal_successive_tempo_changes\" : self . delete_equal_successive_tempo_changes , \"sustain_pedal_duration\" : self . sustain_pedal_duration , \"pitch_bend_range\" : self . pitch_bend_range , \"delete_equal_successive_time_sig_changes\" : self . delete_equal_successive_time_sig_changes , \"use_programs\" : self . use_programs , \"use_microtiming\" : self . use_microtiming , \"ticks_per_quarter\" : self . ticks_per_quarter , \"max_microtiming_shift\" : self . max_microtiming_shift , \"num_microtiming_bins\" : self . num_microtiming_bins , \"base_tokenizer\" : self . base_tokenizer , }","title":"TokenizerConfigUser"},{"location":"Development%20documentation/service/TokenizerConfig/#backend.core.service.tokenizer.tokenizer_config.TokenizerConfigUser-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/TokenizerConfig/#backend.core.service.tokenizer.tokenizer_config.TokenizerConfigUser.__init__","text":"Initialize the TokenizerConfigUser with parameters from a user ConfigModel. Parameters: user_config ( ConfigModel ) \u2013 The user-provided configuration model containing tokenization parameters. Source code in backend/core/service/tokenizer/tokenizer_config.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , user_config : ConfigModel ): \"\"\" Initialize the TokenizerConfigUser with parameters from a user ConfigModel. Args: user_config: The user-provided configuration model containing tokenization parameters. \"\"\" self . pitch_range = tuple ( user_config . pitch_range ) self . beat_res = {( 0 , 4 ): 8 , ( 4 , 12 ): 4 } self . num_velocities = user_config . num_velocities self . special_tokens = user_config . special_tokens self . use_chords = user_config . use_chords self . use_rests = user_config . use_rests self . use_tempos = user_config . use_tempos self . use_time_signatures = user_config . use_time_signatures self . use_sustain_pedals = user_config . use_sustain_pedals self . use_pitch_bends = user_config . use_pitch_bends self . num_tempos = user_config . num_tempos self . tempo_range = tuple ( user_config . tempo_range ) self . log_tempos = user_config . log_tempos self . delete_equal_successive_tempo_changes = user_config . delete_equal_successive_tempo_changes self . sustain_pedal_duration = user_config . sustain_pedal_duration self . pitch_bend_range = user_config . pitch_bend_range self . delete_equal_successive_time_sig_changes = user_config . delete_equal_successive_time_sig_changes self . use_programs = user_config . use_programs self . use_microtiming = user_config . use_microtiming self . ticks_per_quarter = user_config . ticks_per_quarter self . max_microtiming_shift = user_config . max_microtiming_shift self . num_microtiming_bins = user_config . num_microtiming_bins # added for MMM self . base_tokenizer = user_config . base_tokenizer","title":"__init__"},{"location":"Development%20documentation/service/TokenizerConfig/#backend.core.service.tokenizer.tokenizer_config.TokenizerConfigUser.get_params","text":"Get all configuration parameters as a dictionary. This method returns all the tokenizer configuration parameters in a dictionary format that can be passed to the tokenizer implementation. Returns: dict \u2013 A dictionary containing all tokenizer configuration parameters. Source code in backend/core/service/tokenizer/tokenizer_config.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def get_params ( self ) -> dict : \"\"\" Get all configuration parameters as a dictionary. This method returns all the tokenizer configuration parameters in a dictionary format that can be passed to the tokenizer implementation. Returns: A dictionary containing all tokenizer configuration parameters. \"\"\" return { \"pitch_range\" : self . pitch_range , \"beat_res\" : self . beat_res , \"num_velocities\" : self . num_velocities , \"special_tokens\" : self . special_tokens , \"use_chords\" : self . use_chords , \"use_rests\" : self . use_rests , \"use_tempos\" : self . use_tempos , \"use_time_signatures\" : self . use_time_signatures , \"use_sustain_pedals\" : self . use_sustain_pedals , \"use_pitch_bends\" : self . use_pitch_bends , \"num_tempos\" : self . num_tempos , \"tempo_range\" : self . tempo_range , \"log_tempos\" : self . log_tempos , \"delete_equal_successive_tempo_changes\" : self . delete_equal_successive_tempo_changes , \"sustain_pedal_duration\" : self . sustain_pedal_duration , \"pitch_bend_range\" : self . pitch_bend_range , \"delete_equal_successive_time_sig_changes\" : self . delete_equal_successive_time_sig_changes , \"use_programs\" : self . use_programs , \"use_microtiming\" : self . use_microtiming , \"ticks_per_quarter\" : self . ticks_per_quarter , \"max_microtiming_shift\" : self . max_microtiming_shift , \"num_microtiming_bins\" : self . num_microtiming_bins , \"base_tokenizer\" : self . base_tokenizer , }","title":"get_params"},{"location":"Development%20documentation/service/TokenizerFactory/","text":"Tokenizer Factory Classes TokenizerFactory Factory class for creating and mapping for MIDI tokenizers. Source code in backend/core/service/tokenizer/tokenizer_factory.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TokenizerFactory : \"\"\" Factory class for creating and mapping for MIDI tokenizers. \"\"\" _registry = {} @classmethod def register_tokenizer ( cls , tokenizer_type : str , tokenizer_cls ): \"\"\" Register a new tokenizer type with its implementation class. This method adds a new tokenizer type to the factory's registry, allowing it to be created later using the get_tokenizer method. Args: tokenizer_type: A string identifier for the tokenizer type (e.g., \"REMI\", \"MIDILike\"). tokenizer_cls: The tokenizer class implementation to associate with this type. The class should be a subclass of MusicTokenizer. \"\"\" cls . _registry [ tokenizer_type ] = tokenizer_cls @classmethod def get_tokenizer ( cls , tokenizer_type : str , config : TokenizerConfig ) -> MusicTokenizer : \"\"\" Create and return a tokenizer instance of the specified type. This method looks up the requested tokenizer type in the registry and creates a new instance with the provided configuration. Args: tokenizer_type: The type of tokenizer to create (e.g., \"REMI\", \"MIDILike\"). Must be a type that has been registered with register_tokenizer. config: A TokenizerConfig object containing the configuration parameters for the tokenizer. Returns: A new instance of the requested tokenizer type, initialized with the provided configuration. Raises: ValueError: If the requested tokenizer type is not registered. \"\"\" if tokenizer_type not in cls . _registry : raise ValueError ( tokenizer_type ) return cls . _registry [ tokenizer_type ]( config ) Functions register_tokenizer ( tokenizer_type : str , tokenizer_cls ) classmethod Register a new tokenizer type with its implementation class. This method adds a new tokenizer type to the factory's registry, allowing it to be created later using the get_tokenizer method. Parameters: tokenizer_type ( str ) \u2013 A string identifier for the tokenizer type (e.g., \"REMI\", \"MIDILike\"). tokenizer_cls \u2013 The tokenizer class implementation to associate with this type. The class should be a subclass of MusicTokenizer. Source code in backend/core/service/tokenizer/tokenizer_factory.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @classmethod def register_tokenizer ( cls , tokenizer_type : str , tokenizer_cls ): \"\"\" Register a new tokenizer type with its implementation class. This method adds a new tokenizer type to the factory's registry, allowing it to be created later using the get_tokenizer method. Args: tokenizer_type: A string identifier for the tokenizer type (e.g., \"REMI\", \"MIDILike\"). tokenizer_cls: The tokenizer class implementation to associate with this type. The class should be a subclass of MusicTokenizer. \"\"\" cls . _registry [ tokenizer_type ] = tokenizer_cls get_tokenizer ( tokenizer_type : str , config : TokenizerConfig ) -> MusicTokenizer classmethod Create and return a tokenizer instance of the specified type. This method looks up the requested tokenizer type in the registry and creates a new instance with the provided configuration. Parameters: tokenizer_type ( str ) \u2013 The type of tokenizer to create (e.g., \"REMI\", \"MIDILike\"). Must be a type that has been registered with register_tokenizer. config ( TokenizerConfig ) \u2013 A TokenizerConfig object containing the configuration parameters for the tokenizer. Returns: MusicTokenizer \u2013 A new instance of the requested tokenizer type, initialized with the provided MusicTokenizer \u2013 configuration. Raises: ValueError \u2013 If the requested tokenizer type is not registered. Source code in backend/core/service/tokenizer/tokenizer_factory.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @classmethod def get_tokenizer ( cls , tokenizer_type : str , config : TokenizerConfig ) -> MusicTokenizer : \"\"\" Create and return a tokenizer instance of the specified type. This method looks up the requested tokenizer type in the registry and creates a new instance with the provided configuration. Args: tokenizer_type: The type of tokenizer to create (e.g., \"REMI\", \"MIDILike\"). Must be a type that has been registered with register_tokenizer. config: A TokenizerConfig object containing the configuration parameters for the tokenizer. Returns: A new instance of the requested tokenizer type, initialized with the provided configuration. Raises: ValueError: If the requested tokenizer type is not registered. \"\"\" if tokenizer_type not in cls . _registry : raise ValueError ( tokenizer_type ) return cls . _registry [ tokenizer_type ]( config )","title":"Tokenizer Factory"},{"location":"Development%20documentation/service/TokenizerFactory/#tokenizer-factory","text":"","title":"Tokenizer Factory"},{"location":"Development%20documentation/service/TokenizerFactory/#backend.core.service.tokenizer.tokenizer_factory-classes","text":"","title":"Classes"},{"location":"Development%20documentation/service/TokenizerFactory/#backend.core.service.tokenizer.tokenizer_factory.TokenizerFactory","text":"Factory class for creating and mapping for MIDI tokenizers. Source code in backend/core/service/tokenizer/tokenizer_factory.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class TokenizerFactory : \"\"\" Factory class for creating and mapping for MIDI tokenizers. \"\"\" _registry = {} @classmethod def register_tokenizer ( cls , tokenizer_type : str , tokenizer_cls ): \"\"\" Register a new tokenizer type with its implementation class. This method adds a new tokenizer type to the factory's registry, allowing it to be created later using the get_tokenizer method. Args: tokenizer_type: A string identifier for the tokenizer type (e.g., \"REMI\", \"MIDILike\"). tokenizer_cls: The tokenizer class implementation to associate with this type. The class should be a subclass of MusicTokenizer. \"\"\" cls . _registry [ tokenizer_type ] = tokenizer_cls @classmethod def get_tokenizer ( cls , tokenizer_type : str , config : TokenizerConfig ) -> MusicTokenizer : \"\"\" Create and return a tokenizer instance of the specified type. This method looks up the requested tokenizer type in the registry and creates a new instance with the provided configuration. Args: tokenizer_type: The type of tokenizer to create (e.g., \"REMI\", \"MIDILike\"). Must be a type that has been registered with register_tokenizer. config: A TokenizerConfig object containing the configuration parameters for the tokenizer. Returns: A new instance of the requested tokenizer type, initialized with the provided configuration. Raises: ValueError: If the requested tokenizer type is not registered. \"\"\" if tokenizer_type not in cls . _registry : raise ValueError ( tokenizer_type ) return cls . _registry [ tokenizer_type ]( config )","title":"TokenizerFactory"},{"location":"Development%20documentation/service/TokenizerFactory/#backend.core.service.tokenizer.tokenizer_factory.TokenizerFactory-functions","text":"","title":"Functions"},{"location":"Development%20documentation/service/TokenizerFactory/#backend.core.service.tokenizer.tokenizer_factory.TokenizerFactory.register_tokenizer","text":"Register a new tokenizer type with its implementation class. This method adds a new tokenizer type to the factory's registry, allowing it to be created later using the get_tokenizer method. Parameters: tokenizer_type ( str ) \u2013 A string identifier for the tokenizer type (e.g., \"REMI\", \"MIDILike\"). tokenizer_cls \u2013 The tokenizer class implementation to associate with this type. The class should be a subclass of MusicTokenizer. Source code in backend/core/service/tokenizer/tokenizer_factory.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @classmethod def register_tokenizer ( cls , tokenizer_type : str , tokenizer_cls ): \"\"\" Register a new tokenizer type with its implementation class. This method adds a new tokenizer type to the factory's registry, allowing it to be created later using the get_tokenizer method. Args: tokenizer_type: A string identifier for the tokenizer type (e.g., \"REMI\", \"MIDILike\"). tokenizer_cls: The tokenizer class implementation to associate with this type. The class should be a subclass of MusicTokenizer. \"\"\" cls . _registry [ tokenizer_type ] = tokenizer_cls","title":"register_tokenizer"},{"location":"Development%20documentation/service/TokenizerFactory/#backend.core.service.tokenizer.tokenizer_factory.TokenizerFactory.get_tokenizer","text":"Create and return a tokenizer instance of the specified type. This method looks up the requested tokenizer type in the registry and creates a new instance with the provided configuration. Parameters: tokenizer_type ( str ) \u2013 The type of tokenizer to create (e.g., \"REMI\", \"MIDILike\"). Must be a type that has been registered with register_tokenizer. config ( TokenizerConfig ) \u2013 A TokenizerConfig object containing the configuration parameters for the tokenizer. Returns: MusicTokenizer \u2013 A new instance of the requested tokenizer type, initialized with the provided MusicTokenizer \u2013 configuration. Raises: ValueError \u2013 If the requested tokenizer type is not registered. Source code in backend/core/service/tokenizer/tokenizer_factory.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @classmethod def get_tokenizer ( cls , tokenizer_type : str , config : TokenizerConfig ) -> MusicTokenizer : \"\"\" Create and return a tokenizer instance of the specified type. This method looks up the requested tokenizer type in the registry and creates a new instance with the provided configuration. Args: tokenizer_type: The type of tokenizer to create (e.g., \"REMI\", \"MIDILike\"). Must be a type that has been registered with register_tokenizer. config: A TokenizerConfig object containing the configuration parameters for the tokenizer. Returns: A new instance of the requested tokenizer type, initialized with the provided configuration. Raises: ValueError: If the requested tokenizer type is not registered. \"\"\" if tokenizer_type not in cls . _registry : raise ValueError ( tokenizer_type ) return cls . _registry [ tokenizer_type ]( config )","title":"get_tokenizer"},{"location":"Technical%20documentation/RailwayDeploy/","text":"Deploying the Application to Railway The application can be successfully deployed using the Railway platform. To do so, you'll need to use the files from the railway folder and make a few configuration changes. Note : Railway offers a free trial that allows deployments, but it is limited to 5$. Deployment Steps Sign Up and Connect GitHub Repository Register on Railway and connect your GitHub repository. Create Two Services Set up two separate services \u2014 one for the frontend and one for the backend. Set Environment Variables For each service, add the environment variable RAILWAY_DOCKERFILE_PATH , pointing to the respective Dockerfile location inside the railway folder. Dockerfile FROM python:3.11-buster AS builder RUN apt-get update && apt-get install -y libc6 RUN pip install poetry == 1 .6.1 ENV POETRY_NO_INTERACTION = 1 \\ POETRY_VIRTUALENVS_IN_PROJECT = 1 \\ POETRY_VIRTUALENVS_CREATE = 1 ENV REACT_APP_API_BASE_URL = \"https://miditok-visualizer-front-production.up.railway.app\" WORKDIR /app COPY backend/pyproject.toml backend/poetry.lock ./ RUN touch README.md RUN poetry install --no-root COPY backend/core ./core COPY backend/tests ./tests RUN poetry run pytest FROM python:3.11-slim-buster AS runtime ENV VIRTUAL_ENV = /app/.venv \\ PATH = \"/app/.venv/bin: $PATH \" \\ REACT_APP_API_BASE_URL = \"https://miditok-visualizer-front-production.up.railway.app\" COPY --from = builder /app/.venv /app/.venv WORKDIR /app COPY backend/core ./core ENTRYPOINT [ \"python\" , \"-m\" , \"core.main\" ] Configure Ports After deployment, set the following ports: Frontend: 3000 Backend: 8000 Add the railway.json File In the Config as Code section, add the railway.json file and update the service names by assigning the correct RAILWAY_SERVICE_ID variables. railway.json { \"services\": { \"7c51be2c-4e29-415e-bc14-40e7c7537aec\": { \"name\": \"back\", \"build\": { \"builder\": \"docker\", \"dockerfilePath\": \"railway/backend/Dockerfile\", \"buildContext\": \".\" } }, \"114f992a-2c0a-49f9-be31-8c9b830d1bbb\": { \"name\": \"front\", \"build\": { \"builder\": \"docker\", \"dockerfilePath\": \"railway/frontend/Dockerfile\", \"buildContext\": \".\" } } } } Update Dockerfiles Once the services are deployed, update the Dockerfiles by replacing the environment variables for frontend and backend URLs with the ones provided by Railway. Enable Sleep Mode for Backend To reduce data transfer usage, consider enabling sleep mode for the backend service when it's idle.","title":"Deploying the Application to Railway"},{"location":"Technical%20documentation/RailwayDeploy/#deploying-the-application-to-railway","text":"The application can be successfully deployed using the Railway platform. To do so, you'll need to use the files from the railway folder and make a few configuration changes. Note : Railway offers a free trial that allows deployments, but it is limited to 5$.","title":"Deploying the Application to Railway"},{"location":"Technical%20documentation/RailwayDeploy/#deployment-steps","text":"Sign Up and Connect GitHub Repository Register on Railway and connect your GitHub repository. Create Two Services Set up two separate services \u2014 one for the frontend and one for the backend. Set Environment Variables For each service, add the environment variable RAILWAY_DOCKERFILE_PATH , pointing to the respective Dockerfile location inside the railway folder. Dockerfile FROM python:3.11-buster AS builder RUN apt-get update && apt-get install -y libc6 RUN pip install poetry == 1 .6.1 ENV POETRY_NO_INTERACTION = 1 \\ POETRY_VIRTUALENVS_IN_PROJECT = 1 \\ POETRY_VIRTUALENVS_CREATE = 1 ENV REACT_APP_API_BASE_URL = \"https://miditok-visualizer-front-production.up.railway.app\" WORKDIR /app COPY backend/pyproject.toml backend/poetry.lock ./ RUN touch README.md RUN poetry install --no-root COPY backend/core ./core COPY backend/tests ./tests RUN poetry run pytest FROM python:3.11-slim-buster AS runtime ENV VIRTUAL_ENV = /app/.venv \\ PATH = \"/app/.venv/bin: $PATH \" \\ REACT_APP_API_BASE_URL = \"https://miditok-visualizer-front-production.up.railway.app\" COPY --from = builder /app/.venv /app/.venv WORKDIR /app COPY backend/core ./core ENTRYPOINT [ \"python\" , \"-m\" , \"core.main\" ] Configure Ports After deployment, set the following ports: Frontend: 3000 Backend: 8000 Add the railway.json File In the Config as Code section, add the railway.json file and update the service names by assigning the correct RAILWAY_SERVICE_ID variables. railway.json { \"services\": { \"7c51be2c-4e29-415e-bc14-40e7c7537aec\": { \"name\": \"back\", \"build\": { \"builder\": \"docker\", \"dockerfilePath\": \"railway/backend/Dockerfile\", \"buildContext\": \".\" } }, \"114f992a-2c0a-49f9-be31-8c9b830d1bbb\": { \"name\": \"front\", \"build\": { \"builder\": \"docker\", \"dockerfilePath\": \"railway/frontend/Dockerfile\", \"buildContext\": \".\" } } } } Update Dockerfiles Once the services are deployed, update the Dockerfiles by replacing the environment variables for frontend and backend URLs with the ones provided by Railway. Enable Sleep Mode for Backend To reduce data transfer usage, consider enabling sleep mode for the backend service when it's idle.","title":"Deployment Steps"}]}